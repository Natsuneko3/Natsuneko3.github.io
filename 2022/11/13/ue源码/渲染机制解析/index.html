<!DOCTYPE html><html lang="ch"><head><link rel="stylesheet" href="/css/bilicard.css"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="夏猫" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="夏猫" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="夏猫" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记,UE源码"><link rel="canonical" href="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"><meta name="description" content="# 渲染机制解析    类型 解析     UPrimitiveComponent 图元组件，是所有可渲染或拥有物理模拟的物体父类。是 CPU 层裁剪的最小粒度单位。   FPrimitiveSceneProxy 图元场景代理，是 UPrimitiveComponent 在渲染器的代表，镜像了 UPrimitiveComponent 在渲染线程的状态。   FPrimitiveSceneInfo"><meta property="og:type" content="article"><meta property="og:title" content="渲染机制解析"><meta property="og:url" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/index.html"><meta property="og:site_name" content="夏猫"><meta property="og:description" content="# 渲染机制解析    类型 解析     UPrimitiveComponent 图元组件，是所有可渲染或拥有物理模拟的物体父类。是 CPU 层裁剪的最小粒度单位。   FPrimitiveSceneProxy 图元场景代理，是 UPrimitiveComponent 在渲染器的代表，镜像了 UPrimitiveComponent 在渲染线程的状态。   FPrimitiveSceneInfo"><meta property="og:locale"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled9.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled10.png"><meta property="og:image" content="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319203832841-1939790306.jpg"><meta property="og:image" content="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319203846059-346871767.jpg"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%201.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%202.png"><meta property="og:image" content="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319204117391-930676450.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/U2.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%203.png"><meta property="og:image" content="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319204138477-1053404240.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/U1.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%204.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%205.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%206.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%207.png"><meta property="og:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled%208.png"><meta property="article:published_time" content="2022-11-13T04:00:00.000Z"><meta property="article:modified_time" content="2023-01-30T11:55:59.000Z"><meta property="article:author" content="Natsuneko"><meta property="article:tag" content="笔记"><meta property="article:tag" content="UE源码"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/Untitled9.png"><meta name="twitter:creator" content="@natsunekosan"><title>渲染机制解析 - UE 源码笔记 | Natsu neko = 夏猫 = 嵐です！</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">渲染机制解析</h1><div class="meta"><span class="item" title="创建时间：2022-11-13 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-11-13T12:00:00+08:00">2022-11-13</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Natsu neko</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-9mk97d.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-dpokm3.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-8ogx62.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-6omewl.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-q25dq5.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-2yy589.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 UE 源码笔记"><span itemprop="name">UE 源码笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="ch"><link itemprop="mainEntityOfPage" href="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Natsuneko"><meta itemprop="description" content="嵐です！, 主要分享关于 ue 或者 TA 的知识，也或者分享点自己想写的东西，作品什么的"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夏猫"></span><div class="body md" itemprop="articleBody"><h1 id="渲染机制解析"><a class="anchor" href="#渲染机制解析">#</a> 渲染机制解析</h1><table><thead><tr><th>类型</th><th>解析</th></tr></thead><tbody><tr><td>UPrimitiveComponent</td><td>图元组件，是所有可渲染或拥有物理模拟的物体父类。是 CPU 层裁剪的最小粒度单位。</td></tr><tr><td>FPrimitiveSceneProxy</td><td>图元场景代理，是 UPrimitiveComponent 在渲染器的代表，镜像了 UPrimitiveComponent 在渲染线程的状态。</td></tr><tr><td>FPrimitiveSceneInfo</td><td>渲染器内部状态（描述了 FRendererModule 的实现），相当于融合了 UPrimitiveComponent and FPrimitiveSceneProxy。只存在渲染器模块，所以引擎模块无法感知到它的存在。</td></tr><tr><td>FScene</td><td>是 UWorld 在渲染模块的代表。只有加入到 FScene 的物体才会被渲染器感知到。渲染线程拥有 FScene 的所有状态（游戏线程不可直接修改）。</td></tr><tr><td>FSceneView</td><td>描述了 FScene 内的单个视图（view），同个 FScene 允许有多个 view，换言之，一个场景可以被多个 view 绘制，或者多个 view 同时被绘制。每一帧都会创建新的 view 实例。</td></tr><tr><td>FViewInfo</td><td>view 在渲染器的内部代表，只存在渲染器模块，引擎模块不可见。</td></tr><tr><td>FSceneRenderer</td><td>每帧都会被创建，封装帧间临时数据。下派生 FDeferredShadingSceneRenderer（延迟着色场景渲染器）和 FMobileSceneRenderer（移动端场景渲染器），分别代表 PC 和移动端的默认渲染器。</td></tr><tr><td>FMeshBatchElement</td><td>单个网格模型的数据，包含网格渲染中所需的部分数据，如顶点、索引、UniformBuffer 及各种标识等。</td></tr><tr><td>FMeshBatch</td><td>存着一组 FMeshBatchElement 的数据，这组 FMeshBatchElement 的数据拥有相同的材质和顶点缓冲。</td></tr><tr><td>FMeshDrawCommand</td><td>完整地描述了一个 Pass Draw Call 的所有状态和数据，如 shader 绑定、顶点数据、索引数据、PSO 缓存等。</td></tr><tr><td>FMeshPassProcessor</td><td>网格渲染 Pass 处理器，负责将场景中感兴趣的网格对象执行处理，将其由 FMeshBatch 对象转成一个或多个 FMeshDrawCommand。</td></tr></tbody></table><p>需要特意指出，以上概念中除了 UPrimitiveComponent 是属于游戏线程的对象，其它皆属于渲染线程。</p><p>每一个 MeshPass 对应一个 <code>PassProcessor</code> ，每个 <code>PassProcessor</code> 都会有一个 <code>FMeshPassProcessorRenderState</code> 类型的实例输入，用来设置该 Pass 相关的状态、 <code>UniformBuffer</code> 等。<br><code>FMaterialRenderProxy</code> 是 <code>FMaterial</code> 用于渲染线程的代理，它可以透过 <code>FMaterail</code> 和 <code>UMaterialInterface</code> 访问到 Shader、渲染状态，光照模型等所有用户设置好的材质参数。<br><code>FMeshPassProcessorRenderState</code> 可以将一系列渲染状态重写，传递给 <code>Mesh Pass Processor</code> ，可以用于在外部进行配置。</p><p><img data-src="Untitled9.png" alt="Untitled"></p><p><img data-src="Untitled10.png" alt="Untitled"></p><h2 id="渲染流程"><a class="anchor" href="#渲染流程">#</a> 渲染流程</h2><p>在 UE4.21 之前，为了达到上述的目的，采用了网格渲染流程（Mesh Draw Pipeline），示意图如下：</p><p><img data-src="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319203832841-1939790306.jpg" alt="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319203832841-1939790306.jpg"></p><p><em>UE4.21 及之前版本的网格绘制流程。</em></p><p>大致过程是渲染之时，渲染器会遍历场景的所有经过了可见性测试的 PrimitiveSceneProxy 对象，利用其接口收集不同的 FMeshBatch，然后在不同的渲染 Pass 中遍历这些 FMeshBatch，利用 Pass 对应的 DrawingPolicy 将其转成 RHI 的命令列表，最后才会生成对应图形 API 的指令，提交到 GPU 硬件中执行。</p><p>UE4.22 在此基础上，为了更好地做渲染优化，给网格渲染管线进行了一次比较大的重构，抛弃了低效率的 DrawingPolicy，用 PassMeshProcessor 取而代之，在 FMeshBatch 和 RHI 命令之间增加了一个概念 FMeshDrawCommand，以便更大程度更加可控地排序、缓存、合并绘制指令：</p><p><img data-src="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319203846059-346871767.jpg" alt="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319203846059-346871767.jpg"></p><p><em>UE4.22 重构后新的网格绘制流程。增加了新的 FMeshDrawCommand 和 FMeshPassProcessor 等概念及操作。</em></p><p>这样做的目的主要有两个：</p><ul><li>支持 RTX 的实时光线追踪。光线追踪需要遍历整个场景的物体，要保留整个场景的 shader 资源。</li><li>GPU 驱动的渲染管线。包含 GPU 裁剪，所以 CPU 没法知道每一帧的可见性，但又不能每帧建立整个场景的绘制指令，否则无法达成实时渲染。</li></ul><p>为了达成上述的目的，重构后的管线采取了更多聚合缓存措施，体现在：</p><ul><li>静态图元在加入场景时就建立绘制指令，然后缓存。</li><li>允许 RHI 层做尽可能多的预处理。</li></ul><blockquote><ul><li>shader Binding Table Entry。</li><li>Graphics Pipeline State。</li></ul></blockquote><ul><li>避免静态网格每帧都重建绘制指令。</li></ul><p>这里 MobileSceneRender 的动态渲染路径和 PC 端相比几乎没有区别。</p><p><img data-src="Untitled.png" alt="Untitled"></p><p>首先场景中的物体会经历相机裁剪及遮挡剔除，然后会调用 ComputeAndMarkRelevanceForViewParallel 函数来标记需要渲染的物体使用什么渲染路径。</p><p>每个物体被封装到 FRelevancePacket，然后通过异步任务判断该物体的渲染路径。</p><p>OutHasDynamicMeshElementsMasks 中会记录哪些物体是需要动态渲染路径的，然后会调用 FSceneRenderer::GatherDynamicMeshElements 函数。如果被标记为动态渲染路径的物体会调用对于 Proxy 的 GatherDynamicMeshElements 函数。</p><h2 id="从fprimitivesceneproxy到fmeshbatch"><a class="anchor" href="#从fprimitivesceneproxy到fmeshbatch">#</a> 从 FPrimitiveSceneProxy 到 FMeshBatch</h2><p>FPrimitiveSceneProxy 是游戏线程 UPrimitiveComponent 在渲染线程的镜像数据，FMeshBatch 是本节才接触的新概念，它包含了绘制 Pass 所需的所有信息，解耦了网格 Pass 和 FPrimitiveSceneProxy，所以 FPrimitiveSceneProxy 并不知道会被哪些 Pass 绘制。</p><p><img data-src="Untitled%201.png" alt="Untitled"></p><p><em>一个 FMeshBatch 拥有一组 FMeshBatchElement、一个顶点工厂和一个材质实例，同一个 FMeshBatch 的所有 FMeshBatchElement 共享着相同的材质和顶点缓冲（可可被视为 Vertex Factory）。但通常情况（大多数情况）下，FMeshBatch 只会有一个 FMeshBatchElement。</em></p><hr><p>FSkeletalMeshSceneProxy 会根据不同的 LOD 索引，给每个 Section 网格添加一个 FMeshBatch，每个 FMeshBatch 只有一个 FMeshBatchElement 实例。此外 <code>FSceneRender::GatherDynamicMeshElements</code> 的逻辑中还有关键的一句 <code>ComputeDynamicMeshRelevance</code> ，它的作用是计算当前的 MeshBatch 会被哪些 MeshPass 引用，从而加到 view 的对应 MeshPass 的计数中</p><p><code>FMeshElementCollector</code> 它的作用是收集指定 view 的所有可见 MeshBatch 信息，FMeshElementCollector 和 FSceneRenderer 是一一对应关系，每个 FSceneRenderer 拥有一个收集器。收集器收集完对应 view 的可见图元列表后，通常拥有一组需要渲染的 FMeshBatch 列表，以及它们的管理数据和状态，为后续的流程收集和准备足够的准备。此外，FMeshElementCollector 在收集完网格数据后，还可以指定需要等待处理的任务列表，以实现多线程并行处理的同步。收集完动态的 MeshElement，实际上，紧接着会调用 <code>SetupMeshPass</code> 来创建 <code>FMeshPassProcessor</code></p><p><code>FMeshPassProcessor</code> 的主要作用是：</p><ul><li>Pass 过滤。将该 Pass 无关的 MeshBatch 给过滤掉，比如深度 Pass 过滤掉透明物体。</li><li>选择绘制命令所需的 Shader 及渲染状态（深度、模板、混合状态、光栅化状态等）。</li><li>收集绘制命令涉及的 Shader 资源绑定。</li><li>Pass 的 Uniform Buffer，如 ViewUniformBuffer、DepthPassUniformBuffer。</li><li>顶点工厂绑定（顶点数据和索引）。</li><li>材质绑定。</li><li>Pass 的与绘制指令相关的绑定。</li><li>收集 Draw Call 相关的参数。</li></ul><p><code>FMeshPassProcessor::BuildMeshDrawCommands</code> 在最后阶段会调用 <code>FMeshPassDrawListContext::FinalizeCommand</code> 。 <code>FMeshPassDrawListContext</code> 提供了两个基本接口，是个抽象类，派生类有 <code>FDynamicPassMeshDrawListContext</code> 和 <code>FCachedPassMeshDrawListContext</code> ，分别代表了动态网格绘制指令和缓存网格绘制指令的上下文。</p><h2 id="从fmeshbatch到fmeshdrawcommand"><a class="anchor" href="#从fmeshbatch到fmeshdrawcommand">#</a> 从 FMeshBatch 到 FMeshDrawCommand</h2><p></p><figure class="highlight cpp"><figcaption><span>""</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FSceneRenderer::SetupMeshPass</span><span class="hljs-params">(FViewInfo&amp; View, FExclusiveDepthStencil::Type BasePassDepthStencilAccess, FViewCommands&amp; ViewCommands)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> EShadingPath ShadingPath = Scene-&gt;<span class="hljs-built_in">GetShadingPath</span>();<br><br><span class="hljs-comment">// 遍历EMeshPass定义的所有Pass。</span><br><span class="hljs-keyword">for</span> (int32 PassIndex = <span class="hljs-number">0</span>; PassIndex &lt; EMeshPass::Num; PassIndex++)<br>&#123;<br><span class="hljs-type">const</span> EMeshPass::Type PassType = (EMeshPass::Type)PassIndex;<br><br><span class="hljs-keyword">if</span> ((FPassProcessorManager::<span class="hljs-built_in">GetPassFlags</span>(ShadingPath, PassType) &amp; EMeshPassFlags::MainView) != EMeshPassFlags::None)<br>&#123;<br>(......)<br><br><span class="hljs-comment">// 创建FMeshPassProcessor</span><br>PassProcessorCreateFunction CreateFunction = FPassProcessorManager::<span class="hljs-built_in">GetCreateFunction</span>(ShadingPath, PassType);<br>FMeshPassProcessor* MeshPassProcessor = <span class="hljs-built_in">CreateFunction</span>(Scene, &amp;View, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-comment">// 获取指定Pass的FParallelMeshDrawCommandPass对象。</span><br>FParallelMeshDrawCommandPass&amp; Pass = View.ParallelMeshDrawCommandPasses[PassIndex];<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ShouldDumpMeshDrawCommandInstancingStats</span>())<br>&#123;<br>Pass.<span class="hljs-built_in">SetDumpInstancingStats</span>(<span class="hljs-built_in">GetMeshPassName</span>(PassType));<br>&#125;<br><br><span class="hljs-comment">// 并行地处理可见Pass的处理任务，创建此Pass的所有绘制命令。</span><br>Pass.<span class="hljs-built_in">DispatchPassSetup</span>(<br>Scene,<br>View,<br>PassType,<br>BasePassDepthStencilAccess,<br>MeshPassProcessor,<br>View.DynamicMeshElements,<br>&amp;View.DynamicMeshElementsPassRelevance,<br>View.NumVisibleDynamicMeshElements[PassType],<br>ViewCommands.DynamicMeshCommandBuildRequests[PassType],<br>ViewCommands.NumDynamicMeshCommandBuildRequestElements[PassType],<br> ViewCommands.MeshCommands[PassIndex]);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p></p><p>上面代码涉及的 <code>EMeshPass</code> 枚举定义如下：</p><p></p><figure class="highlight cpp"><figcaption><span>MeshPassProcessor.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Engine\Source\Runtime\Renderer\Public\MeshPassProcessor.h</span><br><br><span class="hljs-keyword">namespace</span> EMeshPass<br>&#123;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span><br>&#123;<br>DepthPass,<span class="hljs-comment">// 深度</span><br>BasePass,<span class="hljs-comment">// 几何/基础</span><br>SkyPass, <span class="hljs-comment">// 天空</span><br>SingleLayerWaterPass, <span class="hljs-comment">// 单层水体</span><br>CSMShadowDepth, <span class="hljs-comment">// 级联阴影深度</span><br>Distortion, <span class="hljs-comment">// 扰动</span><br>Velocity, <span class="hljs-comment">// 速度</span><br><br><span class="hljs-comment">// 透明相关的Pass</span><br>TranslucentVelocity,<br>TranslucencyStandard,<br>TranslucencyAfterDOF,<br>TranslucencyAfterDOFModulate,<br>TranslucencyAll,<br><br>LightmapDensity, <span class="hljs-comment">// 光照图强度</span><br>DebugViewMode,<span class="hljs-comment">// 调试视图模式</span><br>CustomDepth,<span class="hljs-comment">// 自定义深度</span><br>MobileBasePassCSM,<br>MobileInverseOpacity,<br>VirtualTexture,<span class="hljs-comment">// 虚拟纹理</span><br><br><span class="hljs-comment">// 编辑器模式下的特殊Pass</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> WITH_EDITOR</span><br>HitProxy,<br>HitProxyOpaqueOnly,<br>EditorSelection,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>Num,<br>NumBits = <span class="hljs-number">5</span>,<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><p>UE 事先罗列了所有可能需要绘制的 Pass，在 SetupMeshPass 阶段对需要用到的 Pass 并行化地生成 DrawCommand。注意这里只是收集并没有真的的绘制</p><p>FMeshBatch 转换成 FMeshDrawCommand 后，每个 Pass 都对应了一个 FMeshPassProcessor，每个 FMeshPassProcessor 保存了该 Pass 需要绘制的所有 FMeshDrawCommand，以便渲染器在合适的时间触发并渲染。</p><p>在 DispatchPassSetup 里面会设置 TaskContext 的数据，收集生成 MeshCommand 所需的数据。然后加入到 <code>MeshDrawCommandPassSetupTask</code> 。</p><p>DispatchPassSetup 中会为每个 Pass 创建一个 Task 用来创建创建 FMeshDrawCommand。所有的指令会存储到 ViewCommands.MeshCommands [PassIndex] 中，后期模块会从这里拿指令进行渲染。</p><p><code>FMeshDrawCommandPassSetupTask</code> 担当了在网格渲染管线中担当了相当重要的角色， 包含动态网格绘和静态制绘制命令的生成、排序、合并等。其中排序阶段的键值由 <code>FMeshDrawCommandSortKey</code> 决定</p><details class="primary"><summary>FMeshDrawCommandSortKey</summary><div><ul><li><code>FMeshDrawCommandSortKey</code> 虽然可存储 BasePass、透明 Pass、普通 Pass3 种键值，但同时只有一种数据生效。</li><li>键值的计算逻辑分散在不同的文件和阶段。譬如 BasePass 的键值可以发生在 BasePassRendering、DepthRendering 以及 MeshPassProcessor 阶段。其中它们的键值计算逻辑和解析如下表：</li></ul><table><thead><tr><th>键名</th><th>计算代码</th><th>解析</th></tr></thead><tbody><tr><td>VertexShaderHash</td><td>PointerHash(VertexShader)</td><td>材质所用的 VS 的指针哈希值。</td></tr><tr><td>PixelShaderHash</td><td>PointerHash(PixelShader)</td><td>材质所用的 PS 的指针哈希值。</td></tr><tr><td>Masked</td><td>BlendMode == EBlendMode::BLEND_Masked ? 0 : 1</td><td>材质的混合模式是否 Masked。</td></tr><tr><td>MeshIdInPrimitive</td><td>MeshIdInPrimitivePerView[ViewIndex]</td><td>基于视图的共享同一个 Primitive 的稳定的网格 id。</td></tr><tr><td>Distance</td><td>(uint32)~BitInvertIfNegativeFloat(((uint32)&amp;Distance))</td><td>根据 ETranslucentSortPolicy 算出 Distance，再逆转负数距离。</td></tr><tr><td>Priority</td><td>-</td><td>直接从材质指定的透明排序优先级获得。</td></tr></tbody></table><ul><li><code>operator&lt;</code> 直接对比 PackedData，表明越高位的数据优先级越高，具体地说，BasePass 的排序依据首先是判断是否 Masked 的材质，再判断 PS 和 VS 的地址哈希值；同理，透明通道的排序优先级依次是：材质指定的优先级、网格到摄像机的距离、网格 ID。</li></ul><blockquote><p>一般来说，对网格进行排序时，对性能影响最大的因素会作为最大的优先级。</p><p>譬如 BasePass 阶段，Masked 的材质在某些 GPU 设备会严重阻碍并行效率和吞吐量，排在最高位；而 PS 在指令数量、计算复杂度往往高于 VS，故而排在 VS 之前也是合情合理的。</p><p>但是，透明通道的排序有一点比较特殊，那就是物体与摄像机的距离远近关系，因为要正确绘制半透明物体的前后关系，必须将它们从远到近的距离进行绘制，否则前后关系会出现错乱。故而透明通道必须将距离放在最高位（优先级最大）。</p></blockquote><ul><li>PackedData 将若干组数据打包成单个 <code>uint64</code> ，在比较时只需比较一次，可提升排序的效率。否则按照传统的写法，用几个 <code>if-else</code> 语句，势必增加 CPU 指令数量，降低排序效率。</li><li>修改键值和相关的排序逻辑，可自定义排序优先级和算法。譬如增加若干排序维度：纹理、顶点数据、渲染状态等。</li></ul></div></details><p>从 <code>FMeshBatch</code> 到 <code>FMeshDrawCommand</code> 阶段，渲染器做了大量的处理，为的是将 <code>FMeshBatch</code> 转换到 <code>FMeshDrawCommand</code> ，并保存到 FMeshPassProcessor 的 FMeshPassDrawListContext 成员变量中。期间还从各个对象中收集或处理网格绘制指令所需的一切数据，以便进入后续的渲染流程。下图展示了这些关键过程：</p><p><img data-src="Untitled%202.png" alt="Untitled"></p><p>关于 <code>FMeshDrawCommand</code> 的合并，需要补充说明，动态绘制路径模式的 <code>FDynamicPassMeshDrawListContext</code> 的 <code>FMeshDrawCommand</code> 存储于 <code>TArray</code> 结构内，不会合并 <code>FMeshDrawCommand</code> ，亦不会动态实例化网格，但可以提升基于状态排序的鲁棒性。</p><p>缓存（静态）绘制路径模式的 <code>FCachedPassMeshDrawListContext</code> 依靠 <code>FStateBucketMap</code> 实现了合并和计数功能，以便在提交绘制阶段实例化绘制。</p><h2 id="从fmeshdrawcommand到rhicommandlist"><a class="anchor" href="#从fmeshdrawcommand到rhicommandlist">#</a> 从 FMeshDrawCommand 到 RHICommandList</h2><ul><li>每个 Pass 都会执行类似上面的过程，同一帧会执行多次，但并不是所有的 Pass 都会开启，可通过 view 的 PassMask 动态开启和关闭。</li><li>DispatchDraw 和 SubmitMeshDrawCommandsRange 特意采用了扁平化的数组，并且考虑了以下因素：</li></ul><blockquote><ul><li>只通过可见性集合就可以方便快捷地划分 FVisibleMeshDrawCommand 的数组，以便扁平化地将向多线程系统 TaskGraph 提交 FMeshDrawCommand 绘制指令。</li><li>通过对 FMeshDrawCommand 列表的排序和增加 StateCache 减少向 RHICommandList 提交的指令数量，减少 RHICommandList 转换和执行的负载。增加这个步骤后，Fortnite 可以减少 20% 的 RHI 执行时间。</li><li>缓存一致性的遍历。紧密地打包 FMeshDrawCommand，轻量化、扁平化且连续地在内存中存储 SubmitDraw 所需的数据，可以提升缓存和预存取命中率。<br><code>TChunkedArray&lt;FMeshDrawCommand&gt; MeshDrawCommands;</code><br><code>typedef TArray&lt;FVisibleMeshDrawCommand, SceneRenderingAllocator&gt; FMeshCommandOneFrameArray;</code><br><code>TArray&lt;FMeshDrawShaderBindingsLayout, TInlineAllocator&lt;2&gt;&gt;ShaderLayouts;</code><br><code>typedef TArray&lt;FVertexInputStream, TInlineAllocator&lt;4&gt;&gt;FVertexInputStreamArray;</code><br><code>const int32 NumInlineShaderBindings = 10;</code></li></ul></blockquote><ul><li>将 MeshDrawCommandPasses 转成 RHICommandList 的命令时支持并行模式，并行的分配策略只是简单地将地将数组平均分成等同于工作线程的数量，然后每个工作线程执行指定范围的绘制指令。这样做的好处是实现简单快捷易于理解，提升 CPU 的 cache 命中率，缺点是每个组内的任务执行时间可能存在较大的差异，这样整体的执行时间由最长的一组决定，势必拉长了时间，降低并行效率。针对这个问题，笔者想出了一些策略：</li><li>启发性策略。记录上一帧每个 MeshDrawCommand 的执行时间，下一帧根据它们的执行时间将相邻的 MeshDrawCommand 相加，当它们的总和趋近每组的平均值时，作为一组执行体。</li><li>考察 MeshDrawCommand 的某个或某几个属性。比如以网格的面数或材质数为分组的依据，将每组 MeshDrawCommand 的考察属性之和大致相同。</li></ul><p>当然以上策略会增加逻辑复杂度，也可能降低 CPU 的 cache 命中率，实际效果要以运行环境为准。</p><ul><li><code>FMeshDrawCommand::SubmitDraw</code> 的过程做了 PSO 和模板值的缓存，防止向 RHICommandList 提交重复的数据和指令，减少 CPU 和 GPU 的 IO 交互。</li></ul><blockquote><p>CPU 与 GPU 之间的 IO 和渲染状态的切换一直是困扰实时渲染领域的问题，在 CPU 和 GPU 异构的体系中尤为明显。所以，减少 CPU 和 GPU 的数据交互是渲染性能优化的一大措施。采取缓存 PSO 等状态后，在极端情况下，可以带来数倍的性能提升。</p></blockquote><ul><li><code>FMeshDrawCommand::SubmitDraw</code> 支持四种绘制模型，一个维度为是否有顶点索引，另一个维度为是否 Indirect 绘制。</li></ul><blockquote><p>Indirect Draw 简介</p><p>在没有 Indirect Draw 之前，应用程序如果想要实现同一个 Draw Call 绘制多个物体，只能使用 GPU Instance，但是 GPU Instance 有非常多的限制，比如需要完全一样的顶点、索引、渲染状态和材质数据，只允许 Transform 不一样。即使贴图可以打包 Atlas，材质属性和模型网格可以打包 StructuredBuffer，也没法避免每次绘制时顶点数必须一样这一个致命的限制，想要实现 GPU Driven Rendering Pipeline 必须打碎成相同顶点数的 Cluster。</p><p>Indirect Draw 技术的出现，GPU 驱动的渲染管线将变得更加简单且高效。它的核心思想是允许将同一个网格所需的资源引用放入一个 Argument Buffer：</p><p><img data-src="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319204117391-930676450.png" alt="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319204117391-930676450.png"><br><img data-src="U2.png" alt="U"></p><p>不同网格的 Argument Buffer 又可以组成更长的 Buffer：</p><p><img data-src="Untitled%203.png" alt="Untitled"></p><p>由于每个网格的数据可以存储在不同的 GPU 线程中，可以并行地执行多个网格之间的绘制，相较传统的串行绘制必然有明显的效率提升：</p><p><img data-src="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319204138477-1053404240.png" alt="https://img2020.cnblogs.com/blog/1617944/202103/1617944-20210319204138477-1053404240.png"><br><img data-src="U1.png" alt="U"></p><p>但是，Indirect Draw 只在 DirectX11、DirecXt12、Vulkan、Metal 等现代图形 API 中支持。</p></blockquote><h1 id="渲染机制总结"><a class="anchor" href="#渲染机制总结">#</a> <strong>渲染机制总结</strong></h1><h2 id="绘制管线优化技术"><a class="anchor" href="#绘制管线优化技术">#</a> <strong>绘制管线优化技术</strong></h2><p>前面章节已经详细阐述了 UE 是如何将图元从 Component 一步步地转成最终的绘制指令，这样做的目的主要是为了提升渲染性能，总结起来，涉及的优化技术主要有以下几点：</p><ul><li><strong>绘制调用合并</strong></li></ul><p>由于所有的 <code>FMeshDrawCommands</code>  都是事先捕获，而不是立即提交给 GPU，这就给 Draw Call 合并提供了有利的基础保障。不过目前版本的合并是基于 D3D11 的特性，根据 shader 绑定决定是否合并成同一个 instance 调用。基于 D3D12 的聚合合并目前尚未实现。</p><p>除了合并，排序也能使得相似的指令在相邻时间绘制，提升 CPU 和 GPU 的缓存命中，减少调用指令数量。</p><ul><li><strong>动态实例化</strong></li></ul><p>为了合并两个 Draw Call，它们必须拥有一致的 shader 绑定（ <code>FMeshDrawCommand::MatchesForDynamicInstancing</code> 返回 true）。</p><p>当前只有缓存的网格绘制命令才会被动态实例化，并且受 <code>FLocalVertexFactory</code> 是否支持缓存的限制。另外，有一些特殊的情况也会阻止合并：</p><ul><li>Lightmap 产生了很小的纹理（可调整 <code>DefaultEngine.ini</code> 的<strong> MaxLightmapRadius</strong> 参数）。</li><li>逐组件的顶点颜色。</li><li>SpeedTree 带风节点。</li></ul><p>使用控制台命令<strong> r.MeshDrawCommands.LogDynamicInstancingStats 1</strong> 可探查动态实例的效益。</p><ul><li><strong>并行绘制</strong></li></ul><p>大多数的网格绘制任务不是在渲染线程中执行的，而是由 TaskGraph 系统并行触发。并行部分有 Pass 的 Content 设置，动态指令生成 / 排序 / 合并等。</p><p>并行的数量由运行设备的 CPU 核心数量决定，并行开启之后，存在 Join 阶段，以等待并行的所有线程都执行完毕（ <code>FSceneRenderer::WaitForTasksClearSnapshotsAndDeleteSceneRenderer</code> 开启并行绘制等待）。</p><ul><li><strong>缓存绘制指令</strong></li></ul><p>UE 为了提升缓存的比例和效率，分离了动态和静态物体的绘制，分别形成动态绘制路径和静态绘制路径，而静态绘制路径可以在图元加入场景时就缓存 FMeshBatch 和 FMeshDrawCommand，这样就达成了一次生成多次绘制带来的高效益。</p><ul><li><strong>提升缓存命中率</strong></li></ul><p>CPU 或 GPU 的缓存都具体时间局部性和空间局部性原则。时间局部性意味着最近访问的数据如果再次被访问，则缓存命中的概率较大；空间局部性意味着当前在处理的数据的相邻数据被缓存命中的概率较大，还包含预读取（prefetch）命中率。</p><p>UE 通过以下手段来提升缓存命中率：</p><ul><li>基于数据驱动的设计，而非面向对象的设计。</li><li>如 FMeshDrawCommand 的结构设计。</li><li>连续存储数据。</li><li>使用 TChunkedArray 存储 FMeshDrawCommand。</li><li>内存对齐。</li><li>使用定制的内存对齐器和内存分配器。</li><li>轻量化数据结构。</li><li>连续存取数据。</li><li>连续遍历绘制指令。</li><li>绘制指令排序。</li><li>使相似的指令排在一起，充分利用缓存的时间局部性。</li></ul><hr><h1 id="延迟渲染"><a class="anchor" href="#延迟渲染">#</a> 延迟渲染</h1><p><code>FSceneRenderer</code> 是 UE 场景渲染器父类，是 UE 渲染体系的大脑和发动机，在整个渲染体系拥有举足轻重的位置，主要用于处理和渲染场景，生成 RHI 层的渲染指令。 <code>FSceneRenderer</code><br>由游戏线程的 <code>FRendererModule::BeginRenderingViewFamily</code> 负责创建和初始化，然后传递给渲染线程。渲染线程会调用 <code>FSceneRenderer::Render()</code> ，渲染完返回后，会删除 <code>FSceneRenderer</code> 的实例。也就是说， <code>FSceneRenderer</code> 会被每帧创建和销毁。</p><p><code>FSceneRenderer</code> 拥有两个子类： <code>FMobileSceneRenderer</code> 和 <code>FDeferredShadingSceneRenderer</code> 。</p><p><code>FMobileSceneRenderer</code> 是用于移动平台的场景渲染器，默认采用了前向渲染的流程。</p><p><code>FDeferredShadingSceneRenderer</code> 虽然名字叫做延迟着色场景渲染器，但其实集成了包含前向渲染和延迟渲染的两种渲染路径，是 PC 和主机平台的默认场景渲染器</p><p><code>FDeferredShadingSceneRenderer</code> 主要包含了 Mesh Pass、光源、阴影、光线追踪、反射、可见性等几大类接口。其中最重要的接口非 <code>FDeferredShadingSceneRenderer::Render</code> 莫属，它是 <code>FDeferredShadingSceneRenderer</code> 的渲染主入口，主流程和重要接口的调用都直接或间接发生它内部。若细分 <code>FDeferredShadingSceneRenderer::Render</code> 的逻辑，则可以划分成以下主要阶段：</p><table><thead><tr><th>阶段</th><th>解析</th></tr></thead><tbody><tr><td>FScene::UpdateAllPrimitiveSceneInfos</td><td>更新所有图元的信息到 GPU，若启用了 GPUScene，将会用二维纹理或 StructureBuffer 来存储图元的信息。</td></tr><tr><td>FSceneRenderTargets::Allocate</td><td>若有需要（分辨率改变、API 触发），重新分配场景的渲染纹理，以保证足够大的尺寸渲染对应的 view。</td></tr><tr><td>InitViews</td><td>采用裁剪若干方式初始化图元的可见性，设置可见的动态阴影，有必要时会对阴影平截头体和世界求交（全场阴影和逐物体阴影）。</td></tr><tr><td>PrePass / Depth only pass</td><td>提前深度 Pass，用来渲染不透明物体的深度。此 Pass 只会写入深度而不会写入颜色，写入深度时有 disabled、occlusion only、complete depths 三种模式，视不同的平台和 Feature Level 决定。通常用来建立 Hierarchical-Z，以便能够开启硬件的 Early-Z 技术，提升 Base Pass 的渲染效率。</td></tr><tr><td>ComputeLightGrid</td><td></td></tr><tr><td>BuildHZB</td><td>构建 HZB 贴图，取四个像素最远的深度的像素</td></tr><tr><td>Issue Occlusion Queries / BeginOcclusionTests</td><td>开启遮挡渲染，此帧的渲染遮挡数据用于下一帧 InitViews 阶段的遮挡剔除。此阶段主要使用物体的包围盒来渲染，也可能会打包相近物体的包围盒以减少 Draw Call。</td></tr><tr><td>Base pass</td><td>也就是前面章节所说的几何通道。用来渲染不透明物体（Opaque 和 Masked 材质）的几何信息，包含法线、深度、颜色、AO、粗糙度、金属度等等。这些几何信息会写入若干张 GBuffer 中。此阶段不会计算动态光源的贡献，但会计算 Lightmap 和天空光的贡献。</td></tr><tr><td>ShadowDepths</td><td>以灯光视角渲染场景深度，就是 shadowmap</td></tr><tr><td>RenderLumenSceneLighting</td><td>主要更新 Lumen Cards 和计算 lumen 直接关照，计算 radiance</td></tr><tr><td>DiffuseIndirectAndAO</td><td>计算间接关照和 AO，有 SSGI 降噪、屏幕空间探针收集、反射以及非直接光组合等几个阶段</td></tr><tr><td>Lighting</td><td>此阶段也就是前面章节所说的光照通道，是标准延迟着色和分块延迟着色的混合体。会计算开启阴影的光源的阴影图，也会计算每个灯光对屏幕空间像素的贡献量，并累计到 Scene Color 中。此外，还会计算光源也对 translucency lighting volumes 的贡献量。</td></tr><tr><td>SkyAtmosphere</td><td>天空雾或者天空</td></tr><tr><td>Fog</td><td>在屏幕空间计算雾和大气对不透明物体表面像素的影响。</td></tr><tr><td>Translucency</td><td>渲染半透明物体阶段。所有半透明物体由远到近（视图空间）逐个绘制到离屏渲染纹理（offscreen render target，代码中叫 separate translucent render target）中，接着用单独的 pass 以正确计算和混合光照结果。</td></tr><tr><td>Post Processing</td><td>后处理阶段。包含了不需要 GBuffer 的 Bloom、色调映射、Gamma 校正等以及需要 GBuffer 的 SSR、SSAO、SSGI 等。此阶段会将半透明的渲染纹理混合到最终的场景颜色中。</td></tr></tbody></table><p>上面只是简单列出了部分过程而非全部，可以利用 RenderDoc 工具截帧或用命令行 <code>profilegpu</code> 可以查看 UE 每帧的详细渲染过程。</p><h2 id="fsceneupdateallprimitivesceneinfos"><a class="anchor" href="#fsceneupdateallprimitivesceneinfos">#</a> <strong><strong>FScene::UpdateAllPrimitiveSceneInfos</strong></strong></h2><p><code>FScene::UpdateAllPrimitiveSceneInfos</code> 的主要作用是删除、增加、更新 CPU 侧的图元数据，且同步到 GPU 端。其中 GPU 的图元数据存在两种方式：</p><ul><li>每个图元独有一个 Uniform Buffer。在 shader 中需要访问图元的数据时从该图元的 Uniform Buffer 中获取即可。这种结构简单易理解，兼容所有 FeatureLevel 的设备。但是会增加 CPU 和 GPU 的 IO，降低 GPU 的 Cache 命中率。</li><li>使用 Texture2D 或 StructuredBuffer 的 GPU Scene，所有图元的数据按规律放置到此。在 shader 中需要访问图元的数据时需要从 GPU Scene 中对应的位置读取数据。需要 SM5 支持，实现难度高，不易理解，但可减少 CPU 和 GPU 的 IO，提升 GPU Cache 命中率，可更好地支持光线追踪和 GPU Driven Pipeline。</li></ul><p>GPUScene 的 PrimitivesToUpdate 和 PrimitivesMarkedToUpdate 收集好需要更新的所有图元索引后，会在 <code>FDeferredShadingSceneRenderer::Render</code> 的 <code>InitViews</code> 之后同步给 GPU</p><p>开始 <code>FDeferredShadingSceneRenderer::Render</code> 逻辑</p><h2 id="initviews"><a class="anchor" href="#initviews">#</a> <strong><strong>InitViews</strong></strong></h2><p><code>InitViews</code> 是 GPU Scene 的更新之后紧挨着执行。它的处理的渲染逻辑很多且重要：可见性判定，收集场景图元数据和标记，创建可见网格命令，初始化 Pass 渲染所需的数据等等。</p><p>在 <code>InitViews</code> 没有太多逻辑，实际上很多逻辑分散在了上面的一些重要接口中：</p><p><code>PreVisibilityFrameSetup</code> 做了大量的初始化工作，如静态网格、Groom、SkinCache、特效、TAA、ViewState 等等。接着继续分析</p><p><code>ComputeViewVisibility</code> 最重要的功能就是处理图元的可见性，包含平截头体裁剪、遮挡剔除，以及收集动态网格信息、创建光源信息等。</p><p><code>PostVisibilityFrameSetup</code> 的主要工作是利用 view 的视锥裁剪光源，防止视线外或屏幕占比很小或没有光照强度的光源进入 shader 计算。此外，还会处理贴花排序、调整之前帧的 RT 和雾效、光束等。</p><p>在 <code>InitViews</code> 过程：</p><ul><li><strong>PreVisibilityFrameSetup</strong>：可见性判定预处理阶段，主要是初始化和设置静态网格、Groom、SkinCache、特效、TAA、ViewState 等等。</li><li>初始化特效系统（FXSystem）。</li><li><strong>ComputeViewVisibility</strong>：计算视图相关的可见性，执行视锥体裁剪、遮挡剔除，收集动态网格信息，创建光源信息等。</li><li>FPrimitiveSceneInfo::UpdateStaticMeshes：更新静态网格数据。</li><li>ViewState::GetPrecomputedVisibilityData：获取预计算的可见性数据。</li><li>FrustumCull：视锥体裁剪。</li><li><strong>ComputeAndMarkRelevanceForViewParallel</strong>：计算和标记视图并行处理的关联数据。</li><li><strong>GatherDynamicMeshElements</strong>：收集 view 的动态可见元素，上一篇中已经解析过。</li><li><strong><a href="%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%20644e4c95dd3144bb824fa139981aa53e.md">SetupMeshPass</a></strong>：设置网格 Pass 的数据，将 FMeshBatch 转换成 FMeshDrawCommand，上一篇中已经解析过。</li><li>CreateIndirectCapsuleShadows：创建胶囊体阴影。</li><li>UpdateSkyIrradianceGpuBuffer：更新天空体环境光照的 GPU 数据。</li><li>InitSkyAtmosphereForViews：初始化大气效果。</li><li><strong>PostVisibilityFrameSetup</strong>：可见性判定后处理阶段，利用 view 的视锥裁剪光源，处理贴花排序，调整之前帧的 RT 和雾效、光束等。</li><li>View.InitRHIResources：初始化视图的部分 RHI 资源。</li><li>SetupVolumetricFog：初始化和设置体积雾。</li><li>OnStartRender：通知 RHI 已经开启了渲染，以初始化视图相关的数据和资源。</li></ul><h2 id="prepass"><a class="anchor" href="#prepass">#</a> <strong><strong>PrePass</strong></strong></h2><p>PrePass 又被称为提前深度 Pass、Depth Only Pass、Early-Z Pass，用来渲染不透明物体的深度。此 Pass 只会写入深度而不会写入颜色，写入深度时有 disabled、occlusion only、complete depths 三种模式，视不同的平台和 Feature Level 决定。</p><p>PrePass 可以由 DBuffer 发起，也可由 Forward Shading 触发，通常用来建立 Hierarchical-Z，以便能够开启硬件的 Early-Z 技术，还可被用于遮挡剔除，提升 Base Pass 的渲染效率。</p><p>开启 PrePass 需要满足以下两个条件：</p><ul><li>非硬件 Tiled 的 GPU。现代移动端 GPU 通常自带 Tiled，且是 TBDR 架构，已经在 GPU 层做了 Early-Z，无需再显式绘制。</li><li>指定了有效的 EarlyZPassMode 或者渲染器的 bEarlyZPassMovable 不为 0。</li></ul><p>非常值得一提的是：WorldGridMaterial 这个是 prepass 深度材质，使用的 Shading Model 是 Default Lit，材质中也存在冗余的节点。如果想要做极致的优化，建议在配置文件中更改此材质，删除冗余的材质节点，改成 Unlit 模式更佳，以最大化地缩减 shader 指令，提升渲染效率。</p><h2 id="basepass"><a class="anchor" href="#basepass">#</a> <strong>BasePass</strong></h2><p>UE 的 BasePass 就是延迟渲染里的几何通道，用来渲染不透明物体的几何信息，包含法线、深度、颜色、AO、粗糙度、金属度等等，这些几何信息会写入若干张 GBuffer 中。</p><p>Base Pass 正常情况下使用的是 FMeshBatch 收集到的材质，也就是网格自身的材质，唯一不同的是 shader 中不会启用光照计算，类似于 Unlit 模式。总结 BasePass 的绘制嵌套关系，</p><p></p><figure class="highlight cpp"><figcaption><span>""</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">foreach(scene in scenes)<br>&#123;<br>  foreach(view in views)<br>  &#123;<br>    foreach(mesh in meshes)<br>    &#123;<br>      <span class="hljs-built_in">DrawMesh</span>(...) <span class="hljs-comment">// 每次调用渲染就执行一次BasePassVertexShader和BasePassPixelShader的代码.</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h2 id="lightingpass"><a class="anchor" href="#lightingpass">#</a> <strong><strong>LightingPass</strong></strong></h2><p>UE 的 LightingPass 就是前面章节所说的光照通道。此阶段会计算开启阴影的光源的阴影图，也会计算每个灯光对屏幕空间像素的贡献量，并累计到 Scene Color 中。此外，还会计算光源也对 translucency lighting volumes 的贡献量。</p><p>LightingPass 在 <code>FDeferredShadingSceneRenderer::Render</code> 的入口及其相邻重要</p><p>Lighting Pass 的负责的渲染逻辑多而杂，包含间接阴影、间接 AO、透明体积光照、光源计算、LPV、天空光、SSS 等等，但光照计算的核心逻辑在 <code>RenderLights</code></p><p>渲染光源时，会先绘制无阴影的光源，起始索引由 <code>SortedLightSet.SimpleLightsEnd</code> 等变量决定，再绘制带阴影的光源，起始索引由 <code>SortedLightSet.AttenuationLightStart</code> 决定。无阴影的光源才支持 Tiled 和 Clustered。</p><p>无论是否带阴影，渲染光源时最终都会调用 <code>RenderLight</code> （注意不是 <code>RenderLights</code> ）真正地执行单个光源的光照计算。</p><p>无论是平行光源还是局部光源，都是在屏幕空间执行绘制，并且平行光使用覆盖全屏幕的矩形来绘制光照，点光源或区域光使用球体绘制光源，而聚光灯使用圆锥体，这样做的好处是可以快速剔除光源包围盒外的像素，加速光照计算效率。总结 LightingPass 中的嵌套关系，伪代码如下：</p><p></p><figure class="highlight cpp"><figcaption><span>""</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">foreach(scene in scenes)<br>&#123;<br>    foreach(light in lights)<br>    &#123;<br>        foreach(view in views)<br>        &#123;<br>            <span class="hljs-built_in">RenderLight</span>() <span class="hljs-comment">// 每次调用渲染光源就执行一遍DeferredLightVertexShaders和DeferredLightPixelShaders的代码.</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><strong><strong>LightingPass 主要流程：</strong></strong><p></p><ul><li><code>DeferredLightPixelMain</code></li><li><code>SetupLightDataForStandardDeferred</code></li><li><code>GetDynamicLighting</code></li><li><code>GetDynamicLightingSplit</code></li><li><code>GetLocalLightAttenuation</code></li><li><code>GetShadowTerms</code></li><li><code>IntegrateBxDF_CapsuleLight</code></li><li><code>LineIrradiance</code></li><li><code>SphereHorizonCosWrap</code></li><li><code>ClosestPointLineToRay</code></li><li><code>IntegrateBxDF_AreaLight</code></li><li><code>ShadingModelID</code><ul><li><code>DefaultLitBxDF</code></li><li><code>HairBxDF</code></li><li><code>ClearCoatBxDF</code></li><li><code>SubsurfaceBxDF</code></li><li><code>ClothBxDF</code></li><li><code>EyeBxDF</code></li></ul></li><li><code>SphereMaxNoH</code></li><li><code>Diffuse_Lambert</code></li><li><code>RectGGXApproxLTC</code></li><li><code>SpecularGGX</code></li><li><code>LightAccumulator_AddSplit</code></li><li><code>LightAccumulator_GetResultSplit</code></li></ul><h2 id="translucency"><a class="anchor" href="#translucency">#</a> <strong><strong>Translucency</strong></strong></h2><p>Translucency 是渲染半透明物体的阶段，所有半透明物体在视图空间由远到近逐个绘制到离屏渲染纹理（separate translucent render target）中，接着用单独的 pass 以正确计算和混合光照结果。</p><p>半透明阶段会渲染半透明的颜色、扰动纹理（用于折射等效果）、速度缓冲（用于 TAA 抗锯齿、后处理效果），其中最主要的渲染半透明的逻辑在 <code>RenderTranslucency</code></p><p>半透明渲染的 C++ 逻辑和 shader 逻辑跟 Base Pass 比较相似，不同的是半透明只处理半透明物体，Uniform Buffer 部分不一样，Render State 也有所不同，光照算法也有区别计算。但它们的主干逻辑大致雷同</p><h2 id="postprocessing"><a class="anchor" href="#postprocessing">#</a> <strong><strong>PostProcessing</strong></strong></h2><p>后处理阶段，也是 <code>FDeferredShadingSceneRenderer::Render</code> 的最后一个阶段。包含了不需要 GBuffer 的 Bloom、色调映射、Gamma 校正等以及需要 GBuffer 的 SSR、SSAO、SSGI 等。此阶段会将半透明的渲染纹理混合到最终的场景颜色中。</p><p>后处理没有直接使用 <code>RHICommandList</code> ，而用 <code>GraphBuilder</code> 代替之。 <code>GraphBuilder</code> 即是依赖性渲染图（RDG），可以自动裁减无用的 Pass，自动管理 Pass 之间的依赖关系和资源的生命周期，以及资源、PSO、渲染指令的优化。</p><h1 id="移动端渲染流程"><a class="anchor" href="#移动端渲染流程">#</a> 移动端渲染流程</h1><p><strong>FMobileSceneRenderer</strong><br>继承自 FSceneRenderer，它负责移动端的场景渲染流程，而 PC 端是同样继承自 FSceneRenderer 的<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGltbGx5L3AvMTQ3MzI0MTIuaHRtbCM0MzItZmRlZmVycmVkc2hhZGluZ3NjZW5lcmVuZGVyZXI="> FDeferredShadingSceneRenderer</span>。</p><p>FMobileSceneRenderer 的逻辑和步骤：</p><p><img data-src="Untitled%204.png" alt="Untitled"></p><p>渲染流程</p><p>移动端的场景渲染器的主流程也发生在 <code>FMobileSceneRenderer::Render</code> 中</p><p><img data-src="Untitled%205.png" alt="Untitled"></p><p>关于上面的流程图，有以下几点需要加以说明：</p><ul><li>流程图节点 <code>bDeferredShading</code> 和 <code>bDeferredShading2</code> 是同一个变量，这里区分开主要是为了防止 <code>mermaid</code> 语法绘图错误。</li><li>带 * 的节点是有条件的，非必然执行的步骤。</li></ul><p>UE4.26 便加入了移动端的延迟渲染管线，所以上述代码中有前向渲染分支 <code>RenderForward</code> 和延迟渲染分支 <code>RenderDeferred</code> ，它们返回的都是渲染结果 SceneColor。</p><p>移动端也支持了图元 GPU 场景、SDF 阴影、AO、天空大气、虚拟纹理、遮挡剔除等渲染特性。</p><p>自 UE4.26 开始，渲染体系广泛地使用了<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGltbGx5L3AvMTUyMTcwOTAuaHRtbA=="> RDG 系统</span>，移动端的场景渲染器也不例外。上述代码中总共声明了数个 FRDGBuilder 实例，用于计算光源格子，以及渲染天空大气 LUT、自定义深度、速度缓冲、渲染后置事件、后处理等，它们都是相对独立的功能模块或渲染阶段。</p><h2 id="renderforward"><a class="anchor" href="#renderforward">#</a> <strong><strong>RenderForward</strong></strong></h2><p>移动端前向渲染主要步骤跟 PC 端类似，依次渲染 PrePass、BasePass、特殊渲染（贴花、AO、遮挡剔除等）、半透明物体。它们的流程图如下：</p><p><img data-src="Untitled%206.png" alt="Untitled"></p><h2 id="renderdeferred"><a class="anchor" href="#renderdeferred">#</a> <strong><strong>RenderDeferred</strong></strong></h2><p>绘制光源时，按光源类型划分为三个步骤：平行光、非分簇简单光源、局部光源（点光源和聚光灯）。需要注意的是，移动端只支持默认光照模型 (MSM_DefaultLit) 的计算，其它高级光照模型（头发、次表面散射、清漆、眼睛、布料等）暂不支持。</p><p>绘制平行光时，最多只能绘制 1 个，采用的是全屏幕矩形绘制，支持若干级 CSM 阴影。</p><p>绘制非分簇简单光源时，无论是点光源还是聚光灯，都采用球体绘制，不支持阴影。</p><p>绘制局部光源时，会复杂许多，先绘制局部光源模板缓冲，再设置光栅化和深度状态，最后才绘制光源。其中点光源采用球体绘制，不支持阴影；聚光灯采用锥体绘制，可以支持阴影，默认情况下，聚光灯不支持动态光影计算，</p><h3 id="绘制光源"><a class="anchor" href="#绘制光源">#</a> 绘制光源</h3><p>每个局部光源首先绘制光源范围内的 Mask，再计算通过了 Stencil 测试（Early-Z）的像素的光照。具体的剖析过程以下图的聚光灯为例：</p><p><img data-src="Untitled%207.png" alt="Untitled"></p><p><em>上：场景中一盏等待渲染的聚光灯；中：利用模板 Pass 绘制出的模板 Mask（白色区域），标记了屏幕空间中和聚光灯形状重叠且深度更近的像素 ；下：对有效像素进行光照计算后的效果。</em></p><p>执行光照的像素必须在光源形状体之内，光源形状之外的像素会被剔除。模板 Pass 标记的是比光源形状深度更近的像素（光源形状体之外的像素），光源绘制 Pass 通过模板测试剔除模板 Pass 标记的像素，然后再通过深度测试找出在光源形状体内的像素，从而提升光照计算效率。</p><p>移动端的 BasePassPS 的处理过程比较复杂，步骤繁多，主要有：解压插值数据，获取并计算材质属性，计算并缓村 GBuffer，处理或调整 GBuffer 数据，计算前向渲染分支的光照（平行光、局部光），计算距离场、CSM 等阴影，计算天空光，处理静态光照、非直接光和 IBL，计算雾效，以及处理水体、头发、薄层透明度等特殊着色模型。</p><p><img data-src="Untitled%208.png" alt="Untitled"></p><p>−8）。</p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a> <a href="/tags/UE%E6%BA%90%E7%A0%81/" rel="tag"><i class="ic i-tag"></i> UE源码</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-01-30 19:55:59" itemprop="dateModified" datetime="2023-01-30T19:55:59+08:00">2023-01-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Natsuneko 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Natsuneko 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Natsuneko 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Natsuneko <i class="ic i-at"><em>@</em></i>夏猫</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" title="渲染机制解析">http://example.com/2022/11/13/ue源码/渲染机制解析/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/07/DualKawaseBlur/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;pic1.zhimg.com&#x2F;v2-79bce61997eaf687cca50c7dabcb3065_1440w.jpg?source&#x3D;172ae18b" title="【UE4&#x2F;UE5】拓展后期pass实现DualKawaseBlur"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 文章</span><h3>【UE4/UE5】拓展后期pass实现DualKawaseBlur</h3></a></div><div class="item right"><a href="/2022/11/29/oit/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;w.wallhaven.cc&#x2F;full&#x2F;z8&#x2F;wallhaven-z8lmpo.jpg" title="【UE5】浅析UE5.1OIT半透明排序算法"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 文章</span><h3>【UE5】浅析UE5.1OIT半透明排序算法</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">渲染机制解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">渲染流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8Efprimitivesceneproxy%E5%88%B0fmeshbatch"><span class="toc-number">1.2.</span> <span class="toc-text">从 FPrimitiveSceneProxy 到 FMeshBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8Efmeshbatch%E5%88%B0fmeshdrawcommand"><span class="toc-number">1.3.</span> <span class="toc-text">从 FMeshBatch 到 FMeshDrawCommand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8Efmeshdrawcommand%E5%88%B0rhicommandlist"><span class="toc-number">1.4.</span> <span class="toc-text">从 FMeshDrawCommand 到 RHICommandList</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">渲染机制总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%AE%A1%E7%BA%BF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.</span> <span class="toc-text">绘制管线优化技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93"><span class="toc-number">3.</span> <span class="toc-text">延迟渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fsceneupdateallprimitivesceneinfos"><span class="toc-number">3.1.</span> <span class="toc-text">FScene::UpdateAllPrimitiveSceneInfos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initviews"><span class="toc-number">3.2.</span> <span class="toc-text">InitViews</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prepass"><span class="toc-number">3.3.</span> <span class="toc-text">PrePass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#basepass"><span class="toc-number">3.4.</span> <span class="toc-text">BasePass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lightingpass"><span class="toc-number">3.5.</span> <span class="toc-text">LightingPass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#translucency"><span class="toc-number">3.6.</span> <span class="toc-text">Translucency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#postprocessing"><span class="toc-number">3.7.</span> <span class="toc-text">PostProcessing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">移动端渲染流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#renderforward"><span class="toc-number">4.1.</span> <span class="toc-text">RenderForward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#renderdeferred"><span class="toc-number">4.2.</span> <span class="toc-text">RenderDeferred</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%85%89%E6%BA%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">绘制光源</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/04/07/ue%E6%BA%90%E7%A0%81/%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/" rel="bookmark" title="材质系统解析">材质系统解析</a></li><li><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/UnifomBuffer/" rel="bookmark" title="UnifomBuffer">UnifomBuffer</a></li><li><a href="/2022/05/18/ue%E6%BA%90%E7%A0%81/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="bookmark" title="智能指针">智能指针</a></li><li class="active"><a href="/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" rel="bookmark" title="渲染机制解析">渲染机制解析</a></li><li><a href="/2023/01/02/NiagaraDataInterface/" rel="bookmark" title="使用自定义Niagara数据接口">使用自定义Niagara数据接口</a></li><li><a href="/2023/01/30/ue%E6%BA%90%E7%A0%81/UEShadowMapRendering/" rel="bookmark" title="阴影渲染机制">阴影渲染机制</a></li><li><a href="/2023/02/03/ue%E6%BA%90%E7%A0%81/Virtual%20Texture%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Virtual Texture解析">Virtual Texture解析</a></li><li><a href="/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/" rel="bookmark" title="RHI解析">RHI解析</a></li><li><a href="/2023/05/31/ue%E6%BA%90%E7%A0%81/%E6%96%B0%E5%BB%BAniagara%20renderer/" rel="bookmark" title="新建niagara renderer">新建niagara renderer</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Natsuneko" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Natsuneko</p><div class="description" itemprop="description">主要分享关于 ue 或者 TA 的知识，也或者分享点自己想写的东西，作品什么的</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">66</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL05hdHN1bmVrbzM=" title="https:&#x2F;&#x2F;github.com&#x2F;Natsuneko3"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9uYXRzdW5la29zYW4=" title="https:&#x2F;&#x2F;twitter.com&#x2F;natsunekosan"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9OYXRzdW5la28=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;Natsuneko"><i class="ic i-zhihu"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVhbHRpbWUueHl6Lw=="><i class="ic i-heart"></i>friends</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/07/DualKawaseBlur/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/29/oit/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Natsuneko @ Natsu neko</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">339k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:08</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/13/ue源码/渲染机制解析/",favicon:{show:"（●´3｀●）感觉还不错把",hide:"____________________________________"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(_){return _.includes("#")},function(_){return new RegExp(LOCAL.path+"$").test(_)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>