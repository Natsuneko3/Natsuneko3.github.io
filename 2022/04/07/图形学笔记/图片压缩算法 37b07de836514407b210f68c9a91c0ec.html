<hr />
<h2 id="title-图片压缩算法date-2022-04-07-1200count-truetags-图形学笔记category-图形学笔记"><a class="anchor" href="#title-图片压缩算法date-2022-04-07-1200count-truetags-图形学笔记category-图形学笔记">#</a> title: 图片压缩算法<br />
 date: 2022-04-07 12:00<br />
count: true<br />
tags: 图形学笔记<br />
 category: 图形学笔记</h2>
<h1 id="图片压缩算法"><a class="anchor" href="#图片压缩算法">#</a> 图片压缩算法</h1>
<h1 id="dxtc"><a class="anchor" href="#dxtc">#</a> <strong>DXTC</strong></h1>
<p>DXTC（或 BC）为微软为 DX 而推出的基于 block 的贴图压缩格式，其主要采用调色板的原理来进行压缩。</p>
<p>BC1:</p>
<p>基于 4x4block 来进行，不含有 alpha 通道，每个 block 内记录两个 16bits 的颜色做为基准颜色，然后解压时再使用两个基准色调制出另外两个颜色做为块内 4 个压缩颜色。其计算方式为：</p>
<p>basecolor2 = 2/3 *basecolor0 + 1/3 * basecolor1</p>
<p>basecolro3 = 1/3 *basecolor0 + 2/3 * basecolor1</p>
<p>对于每个块内的 texel，存储 2bits 的索引，用来指向到 4 个基准颜色中的一个。所以对于 BC1 的压缩状态为 64bits：</p>
<ul>
<li>32bits：两个 RGB565 格式的基准颜色；</li>
<li>32bits：16 个 2bits 的索引；</li>
</ul>
<p>BC3：</p>
<p>在 BC1 的基础上支持 alpha 通道。首先，颜色的存储方式与 BC1 相同，需要 64bits；对于 alpha 部分，使用与颜色部分相同的策略来处理。在 block 存储两个基准的 alpha 值，然后在其基础上插值得到其它 6 个共计 8 个 alpha 值，来做为 alpha 的调色板；然后对于每个 texel 存储一个 3bits 的索引，用来指向到这 8 个 alpha 中的一个。所以其对应的存储状态为：</p>
<ul>
<li>32bits：两个 RGB565 格式的基准颜色；</li>
<li>32bits：16 个 2bits 的颜色索引；</li>
<li>48bits：16 个 3bits 的 alpha 索引；</li>
<li>16bits：2 个 8bits 的基准 alpha；</li>
</ul>
<p>同时，两个 alpha 值中的不同的标记情况也对应着不同的插值操作：</p>
<p>若 alpha0 &gt; alpha1</p>
<p>alphai = (7 - i) / 7 *alpha0 + i/7 * alpha1；（2&lt;=i&lt;=7）；</p>
<p>若 alpha0 &lt; alpha1</p>
<p>alphai = (5 - i) / 5 *alpha0 + i/5 * alpha1；（2&lt;=i&lt;=5）;</p>
<p>alpha6 = 0；</p>
<p>alpha7=255；</p>
<h1 id="etc"><a class="anchor" href="#etc">#</a> <strong>ETC</strong></h1>
<p>ETC 压缩算法采用将图像中的 chromatic 和 luminance 分开存储的方式，而在解码时使用 luminance 对 chromatic 进行调制进而重现原始图像信息。</p>
<p><img src="%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled.png" alt="Untitled" /></p>
<p>ETC 也主要有两种方法：ETC1 和改进后的 ETC2。</p>
<ul>
<li>
<p>ETC1:</p>
<p>采用 4x2 的 block 进行分割（原始为 4<em>2</em>24=192，压缩后为 32，压缩率为 6）：</p>
<p>对于所有图片都使用一个全局的 16 个组 table codeword，每组中有四个数值，且其中是有规律可循的，如下所示：</p>
<p><img src="%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%201.png" alt="Untitled" /></p>
<ul>
<li>12bits：RBG444 的一个 basecolor，其在使用是需要被扩展到 8bits；每个 block 使用 32bits 进行编辑存储；比如对于 RGB=(0,2,15) -&gt; (0000 ,0010 , 1111)，扩展后为 (000000,00100010 , 11111111)-&gt;(0 , 34 , 255)，扩展方法为直接将原始 4 位复制后拼接为 8 位即可；</li>
<li>4bits：用来索引 16 个 table codeword 中的一组，比如｛-10 , -1 , 4 , 7｝；</li>
<li>16bits：对于 block 中的每个 pixel 分配 2bits，就有 4 个值，用来索引当前像素对应于 table codeword 中的每个 modifier，该 modifier 需要组成三个通道的调整值，比如，对于某个 pixel 其对应的 modifier 索引值为 2，也即对应上述 table codeword 中的 4，如此一来该 pixel 的 RGB = (0,34,255) + (4,4,4)=(4,38,259)，最后需要将其 clamp 至 0,255，因而即为 (4,38,255)。</li>
</ul>
<p>改进后采用 4x4 的 block 进行分割（原始为 4<em>4</em>24= 384， 压缩后为 64， 压缩率为 6）：</p>
<p>主要针对某两个 4x2 的 block 间的颜色差异相对较小，因而可以使用一个更多的 bit 来表示一个更高精度的 basecolor，而另外一个 basecolor 则在其基础上通过一个 bit 较小的 diff 来进行动态计算得来。</p>
<p>对于所有图片都使用一个全局的 8 个组 table codeword，每组中有四个数值：</p>
<p><img src="%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%202.png" alt="Untitled" /></p>
<ul>
<li>1bit：用来记录两个字 block 是采用常规的 4*2 编码还是基于差值的编码；</li>
<li>1bit：用来记录 4x4 的 block 内两个子 block 的朝向（可以两个 4<em>2，也可以两个 2</em>4）</li>
<li>32bits：对于 16 个 pixel，每个分配 2bits 的索引，指向到对应的 modifier；</li>
<li>6bits：对于每个子 block，有一个 3bits 的索引，指向 8 个 table codeword 中的某一个（由原始的 16 组 codeword 缩减为 8 个）；</li>
<li>24bits: 分别对应两个 basecolor。对于常规编码时，则是两个 RGB444，然后对每个扩展到 RGB888；对于差值编码时，则是一个 RGB555（精度较高）的 basecolor 和一个差值 RGB333（较低精度），先计算出先求值，然后再扩展。</li>
</ul>
</li>
<li>
<p>ETC2</p>
<p>根据 ETC1 的实现方式，如果其块内的颜色分布不均匀的话，则其存储的两个 basecolor 会较远的分布于插值趋线的较远的两侧，进行解压后会得到较低的压缩质量</p>
<p><img src="%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%203.png" alt="Untitled" /></p>
<p>改进主要针对 ETC1 中的 diff 为 1 的情况下展开，即 basecolor 为 RGB555 和差值 RGB333，此时另外一个颜色值 = RGB555 + dRGB333，而其中的三个通道也是可以独立开来计算的，比如对于红色通道即为 R = R5 + dR3，此时，若其中的 R5 为 0 且 dR3 为负值时得到的红色通道值就没有意义，此种情况下就可以对该 block 重新定义编码方式</p>
<p>针对 ETC1 不支持透明通道的改进，用 ETC2 可以支持透明通道，不过要求 OpenGL ES3.0 及以上（Android4.3+），目前基本覆盖率在 9 成以上</p>
</li>
</ul>
<h1 id="pvrtc"><a class="anchor" href="#pvrtc">#</a> <strong>PVRTC</strong></h1>
<p>PVRTC 的不是基于 block 的方式生成的，但是却也可以理解为以 block 方式组织的。其生成压缩后包含两张 (w/4,h/4) 大小的缩略图（w,h 为原始图片的宽和高，可以理解为第 4 级的 mipmap，但生成过程会比较 mipmap 的复杂），其中的每个 pixel 映射并对应到原始图像中的一个 64x64 的 block 上；然后使用 1 张与原始图像大小相同的 modulate 图，对应的每个 pixel 占 2 个 bits，也即可对应四种调制方式，通过几种不同的调制方式还原出近似的原始像素值。</p>
<p>压缩后的一个 4x4 的 block 中的 bits 的组成内容为：</p>
<ul>
<li>1bit：对应的融合方式，透明或不透明；</li>
<li>32bits：对应于 16 个 pixel，每个 pixel 有 2bits 的调制因子；</li>
<li>31bits：对应两个缩略图中的该块映射到的两个像素上的颜色，若是透明模式，则两个颜色为 RGBA44431，RGBA34431；若是不透明模式，则两个颜色为 RGBA5551，RGBA4551;</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%204.png" alt="Untitled" /></p>
<p>通过调节上述两张缩略图的大小，可以相应的改变对应的压缩比，比如由（w/4，h/4）修改为（w/8，h/4），而其它的映射方式不变，即可将压缩比增大一倍。</p>
<h1 id="astc"><a class="anchor" href="#astc">#</a> <strong>ASTC</strong></h1>
<p>ASTC 中 ARM 研发的一种较新的贴图压缩格式，相对于上述几种方法具有较多的优势，其应该会慢慢成为之后移动设备上贴图压缩的主要标准和主流。其主要具有如下的特性：</p>
<ol>
<li>较高的灵活性；</li>
<li>可变的压缩率；</li>
<li>支持 2d/3d 贴图；</li>
<li>适用于移动平台；</li>
<li>支持 LDR/HDR 贴图内容；</li>
</ol>
<p>ASTC 同样是基于 block 的压缩方式，但块的大小却较支持多种尺寸，比如从基本的 4x4 到 12x12，而且块的宽高也不限于 pot，比如 6x5；每个块内的内容用 128bits 来进行存储，因而不同的块就对应着不同的压缩率。</p>
<p>对于每个块，同样存储两个插值端点，称为 endpoints，但是这里的 endpoints 不一定是基于颜色的（RGBA），也可以基于 layer，比如对于 R,G,B,A 甚或其中的组合如 RG 等，这样的话就可以用来对 normal map 或 alpha map 进行更好的压缩；</p>
<p>对于块中的每个 texel，存储其对应于 endpoints 的插件 weight，但是存储的 weight 数量可以比 texel 少，特别是对于规格较大的块（比如 12x12），这种情况下会首先对于每个 texel 通过线性插值得到其对就应的 weight，然后再进行颜色的计算；</p>
<p>对于块内颜色分布较为复杂的情况，分析块内颜色的分布，然后做 partition，对于每个 partition 进行分别的处理（与 ETC2 中将颜色分布对应到具体的预知分布模式中的处理方法不同），分别存储其对应的 endpoints；这样一来对于块内的某个 texel 进行取值时就先定位其对应的 partition，然后再计算在其在对应的小子块内的颜色。</p>
<p>块内信息的存储采用了 BISE 的方式来进行压缩，尽可能的节省对应的存储空间。比如对于一组 5 个表示范围已知的整型数值，采用 BISE 存储后可节省两个 bits，这样就使用每个块内较大量的数据存储于 128bits 内成为可能；</p>
<p>对于单 layer 的一个 block 内的 bits 组织大概如下所示：</p>
<ul>
<li>11bits: 存储 weight, height, 以及特殊块的标识，比如 void-extent 等；</li>
<li>2bits: part 数量；</li>
<li>4bits: 存储 16 种不同的 endpoints 的模式，比如是 LDR 或 HDR，RGB 或是 RGBA；</li>
<li>111bit：其中存储 endpoints，texel weight 以及其它的配置信息，（注意，每种具体的存储大小是可变的，因其采用 BISE 进行压缩放置）；</li>
</ul>
<p>更多的细节可以看这里</p>
<p><strong>4.1 Bounded Integer sequence encoding</strong></p>
<p>主要是针对范围限定的整数序列进行压缩存储进而节省空间。比如对于三个数 4，78，55，其直接用 binary 的表示为 0000100，1001110，0110111，直接存储二进制序列的话需要 7bits * 3 = 21bits（在已知最大范围为 78 的情况下，不需要存储满 8bits）。但是能不能在 21bits 的基础上再减少呢？BISE 就是实现这样的目的的。</p>
<p>假设序列的范围为 N，对应的 bit 位数为 n：</p>
<ul>
<li>若 N&lt;= 3*2^n-2，则其可用基于 5 的 BISE 压缩；</li>
<li>若 N&lt;=5*2^n-3，则其可用基于 3 的 BISE 压缩。</li>
</ul>
<p>这里的背后其实是基于这样的一个事实，比如在基于 3 的压缩中，如果 N&lt;=3<em>2<sup>n-2，那么在 N 的最高两位 bit 上，其并不会出现 2</sup>2 种情况的所有组合（因其大小是受限的），到少 11 这样的组合就是没有的，否则其对应的值必定大于 N。所以 BISE 压缩就是将受限的整数序列中的前两位数据中的无效 bits 进行合理使用。比如，在上述 4，78，55 的序列中，78 &lt;= 5 * 2^4 = 80，所以可以使用基于 5 的 BISE，将三个数的二进制序列构造为｛000 0100, 100 1100, 011 0111｝，高三位的组合为｛000，100，011｝，因这三个 3 位 bits 序列中的最大值是 5，所以每三个 bits 最多有 5 种情况，那么这个高三位组合的序列共可能有 5^3=125 种组合情况，这样的话就可以使用 7bits 的空间来存储所有的这些组合，如此一来就可以将原来 3</em>3=9bits 的存储空间存储在 7bits 中，进而达到压缩的目的。</p>
