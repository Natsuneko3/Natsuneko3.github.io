<!DOCTYPE html><html lang="ch"><head><link rel="stylesheet" href="/css/bilicard.css"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="夏猫" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="夏猫" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="夏猫" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="图形学笔记"><link rel="canonical" href="http://example.com/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"><meta name="description" content="# HLSL 语言基础 HLSL(High-Level Shading Language， 高级着色语言) 是由微软开发的一种着色器语言，D3D9 及以上版本使用其作为着色语言（注：D3D8 的 shader 使用是类似于汇编的语言来编写），拥有如下特点：  基于 C 语言的语法（如：大小写敏感，每条语句必须以分号结尾），是一门面向过程的强类型语言（type sensitive language）"><meta property="og:type" content="article"><meta property="og:title" content="HLSL 语言基础"><meta property="og:url" content="http://example.com/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="夏猫"><meta property="og:description" content="# HLSL 语言基础 HLSL(High-Level Shading Language， 高级着色语言) 是由微软开发的一种着色器语言，D3D9 及以上版本使用其作为着色语言（注：D3D8 的 shader 使用是类似于汇编的语言来编写），拥有如下特点：  基于 C 语言的语法（如：大小写敏感，每条语句必须以分号结尾），是一门面向过程的强类型语言（type sensitive language）"><meta property="og:locale"><meta property="article:published_time" content="2022-04-07T04:00:00.000Z"><meta property="article:modified_time" content="2022-12-29T17:22:11.000Z"><meta property="article:author" content="Natsuneko"><meta property="article:tag" content="图形学笔记"><meta name="twitter:card" content="summary"><meta name="twitter:creator" content="@natsunekosan"><title>HLSL 语言基础 - 图形学笔记 | Natsu neko = 夏猫 = 嵐です！</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">HLSL 语言基础</h1><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>34k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>31 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Natsu neko</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-yx73xg.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/QQͼƬ20231119143925.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-39xv53.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-x17q6v.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-x1z6po.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-28ggwy.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 图形学笔记"><span itemprop="name">图形学笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="ch"><link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Natsuneko"><meta itemprop="description" content="嵐です！, 主要分享关于 ue 或者 TA 的知识，也或者分享点自己想写的东西，作品什么的"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夏猫"></span><div class="body md" itemprop="articleBody"><h1 id="hlsl语言基础"><a class="anchor" href="#hlsl语言基础">#</a> HLSL 语言基础</h1><p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGlnaC1MZXZlbF9TaGFkaW5nX0xhbmd1YWdl">HLSL</span>(High-Level Shading Language， <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JUFCJTk4JUU3JUJBJUE3JUU3JTlEJTgwJUU4JTg5JUIyJUU1JTk5JUE4JUU4JUFGJUFEJUU4JUE4JTgw">高级着色语言</span>) 是由微软开发的一种着色器语言，D3D9 及以上版本使用其作为着色语言（注：D3D8 的 shader 使用是类似于汇编的语言来编写），拥有如下特点：</p><ol><li>基于 C 语言的语法（如：大小写敏感，每条语句必须以分号结尾），是一门面向过程的强类型语言（type sensitive language）</li><li>除了 bool、int、uint、half、float、double 基础类型外，还支持数组类型，另外 HLSL 还内置了适合 3D 图形操作的向量与矩阵类型，以及采样器（纹理）类型</li><li>基础类型的隐式转换规则与 C 语言一致</li><li>变量没有赋初值时，都会被填充为 false、0 或 0.0</li><li>if 条件语句和 switch 条件语句与 C 语言一致</li><li>for 循环语句和 while 循环语句与 C 语言一致</li><li>return、continue 和 break 与 C 语言一致。另外引入了 discard，该关键字只能在 ps 中使用，表示放弃当前像素，直接处理下一个像素。</li><li>无指针、无字符和字符串类型</li><li>无 union、无 enum</li><li>向量、矩阵可通过构造函数进行初始化</li></ol><h1 id="通用着色器的核心"><a class="anchor" href="#通用着色器的核心">#</a> <strong>通用着色器的核心</strong></h1><p>所有的可编程着色器阶段使用通用着色器核心来实现相同的基础功能。此外，顶点着色阶段、几何着色阶段和像素着色阶段则提供了独特的功能。</p><p>例如几何着色阶段可以生成新的图元或删减图元，像素着色阶段可以决定当前像素是否被抛弃等。</p><p>下图展示了数据是怎么流向一个着色阶段，以及通用着色器核心与着色器内存资源之间的关系：</p><p><strong>Input Data</strong>：顶点着色器从输入装配阶段获取数据；几何着色器则从上一个着色阶段的输出获取等等。通过给形参引入可以使用的系统值可以提供额外的输入</p><p><strong>Output Data</strong>：着色器生成输出的结果然后传递给管线的下一个阶段。有些输出会被通用着色器核心解释成特定用途（如顶点位置、渲染目标对应位置的值），另外一些输出则由应用程序来解释。</p><p><strong>Shader Code</strong>：着色器代码可以从内存读取，然后用于执行代码中所期望的内容。</p><p><strong>Samplers</strong>：采样器决定了如何对纹理进行采样和滤波。</p><p><strong>Textures</strong>：纹理可以使用采样器进行采样，也可以基于索引的方式按像素读取。</p><p><strong>Buffers</strong>：缓冲区可以使用读取相关的内置函数，在内存中按元素直接读取。</p><p><strong>Constant Buffers</strong>：常量缓冲区对常量值的读取有所优化。他们被设计用于 CPU 对这些数据的频繁更新，因此他们有额外的大小、布局和访问限制。</p><h2 id="注释"><a class="anchor" href="#注释">#</a> <strong>注释</strong></h2><p>单行注释</p><p>多行注释</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs raw">/*********************************<br> This is my first HLSL.<br> Let&#x27;s take a look.<br>*********************************/<br></code></pre></td></tr></table></figure><p></p><h2 id="预处理"><a class="anchor" href="#预处理">#</a> <strong>预处理</strong></h2><p>#if #elif [defined (), !defined ()] #else #ifdef #ifndef #endif // 条件编译</p><p></p><figure class="highlight plaintext"><figcaption><span>hlsl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs hlsl">#define TEST1  // 定义为空的宏<br><br>#ifdef TEST1  // 条件成立<br>#endif<br><br>#define TEST1 1 // 定义TEST1宏为1  注：可以不用先undef TEST1宏 但会报warning X1519: &#x27;TEST1&#x27; : macro redefinition<br><br>#undef TEST1  // 取消TEST1宏<br><br>#if TEST1  // 条件不成立<br>#endif<br><br>#ifndef TEST1  // 条件成立<br>#endif<br><br>#define TEST1 -1  // 定义为int的宏<br><br>#define TEST2 // 定义为空的宏<br><br>#if TEST1 &amp;&amp; defined(TEST2) // 条件成立<br>#endif<br><br>#define TEST3 true // 定义为bool的宏<br><br>#if TEST3  // 条件不成立<br>#endif<br><br>#if !TEST3  // 条件成立<br>#endif<br><br>#if TEST3==true  // 条件成立<br>#endif<br><br>#if !defined(TEST0) &amp;&amp; TEST1 &amp;&amp; defined(TEST2) // 条件成立<br>#endif<br><br>#define TEST4 100  // 定义为int的宏<br><br>#if TEST4  // 条件成立<br>#endif<br><br>#if TEST4 &gt; 150<br>#elif (TEST4 &gt; 120) || TEST1 // 进入elif分支<br>#endif<br><br>#if TEST4 &gt; 160<br>#else // 进入else分支<br>#define XX2 1<br>#endif<br><br>#if !TEST4<br>#elif (TEST4 &gt; 110)<br>#else // 进入else分支<br>#endif<br><br>#define TEST5 2.0  // 定义为float的宏<br><br>//#if TEST5  //float不能进行条件判断  编译失败<br>//#endif<br><br>//#if TEST5&gt;0.0  //float不能进行条件判断  编译失败<br>//#endif1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31.32.33.34.35.36.37.38.39.40.41.42.43.44.45.46.47.48.49.50.51.52.53.54.55.56.57.58.59.60.61.62.<br></code></pre></td></tr></table></figure><p></p><p>#define #undef // 宏定义、宏取消</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs raw">#define TEST1 100  // 定义TEST1宏为100<br><br>#ifdef TEST1  // 条件成立<br>#undef TEST1   // 取消TEST1宏的定义<br>#endif<br><br>#if !defined(TEST1) // 条件成立<br>#endif<br><br>#define SQUARE(a) ((a)*(a))<br><br>#define MAX(a,b) \<br>    (((a) &gt; (b)) ? (a) : (b)) // 宏必须在一行写完，多行写时必须带上 \行连接符，但要注意\后不要有空格，否则会编译失败<br><br>#define MERGE(a, b) a##b // ## 字符拼接符1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.<br></code></pre></td></tr></table></figure><p></p><p>#line // 指示下一行的行号，及当前所在的文件；该命令会修改__FILE__、__LINE__的值</p><p>该命令是提供给编译器使用的，程序员最好不要使用该命令</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs raw">#if __LINE__==10  // 判断当前行号是否为10<br>#endif<br><br>#if __FILE__==0  // 条件成立  __FILE__始终为0<br>#endif<br><br>#line 116 // 指定下一行的行号为116<br>#if __LINE__==116  // 条件成立<br>#endif<br><br>#line 200 &quot;test.hlsl&quot;  // 指定下一行的行号为200，当前文件的ID标识为5<br>#if __FILE__==0  // 条件成立   __FILE__始终为0<br>#endif<br><br>// test.hlsl(204,2): error: This is an error!<br>#error This is an error!1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.<br></code></pre></td></tr></table></figure><p></p><p>#error //error 命令被执行，会导致当前文件编译失败</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs raw">// E:\ModenD3D\HLSL-Development-Cookbook\book_sample\Chpater 1 - Forward Light\Ambient Light\ForwardLight.hlsl(40,2): error: This is an error!<br>#error This is an error!<br></code></pre></td></tr></table></figure><p></p><p>#pragma // 用来控制编译器的一些行为</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs raw">#pragma warning( disable : 1519; once : 3205; error : 3206 ) // 忽略1519 warning，只报一次3205 warning，3206 warning视为error<br><br>#define TEST1  // 定义为空的宏<br>#define TEST1 1 // 定义TEST1宏为1  注：可以不用先undef TEST1宏 但会报warning X1519: &#x27;TEST1&#x27; : macro redefinition<br><br>#pragma message(&quot;Hello HLSL.&quot;) //Hello HLSL.<br><br>#pragma pack_matrix( column_major ) // 将uniform参数的matrix设置成列主序（缺省）  注1：列主序生成的指令数更少，因此其效率比行主序的效率要高  注2：构造matrix时不受#pragma pack_matrix影响，始终为行主序<br>#pragma pack_matrix( row_major ) // 将uniform参数的matrix设置成行主序<br><br>#error This is an error! // hlsl中出现error时，才会打印pragma message和warning信息1.2.3.4.5.6.7.8.9.10.11.<br></code></pre></td></tr></table></figure><p></p><p>注 1：需要注意的是，hlsl 中出现 error 时（#error 或语法错误），才会打印 pragma message 和 warning 信息</p><p>注 2：更多 error、warning number 说明，详见： <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZGhsc2wvaGxzbC1lcnJvcnMtYW5kLXdhcm5pbmdz">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/hlsl-errors-and-warnings</span></p><p>注 3：在 C<ins> 代码层中，DirectXMath 数学库创建的矩阵都是行矩阵，但当矩阵从 C</ins> 传递给 HLSL 时，HLSL 默认是列矩阵的，因此传递前要进行了一次转置。如果希望不发生转置操作的话，可以添加修饰关键字 row_major</p><p>#include // 引用其他 hlsl 文件 与 c/c++ 语言用法一致</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs raw">#include &quot;common.hlsl&quot; // 引用其他的hlsl文件<br></code></pre></td></tr></table></figure><p></p><p><strong>typedef</strong></p><p>用于类型的别名，用法与 C 语言一致</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs raw">typedef vector&lt;float, 3&gt; POINT;<br>typedef const float CFLOAT;<br><br>POINT pt;<br>CFLOAT cf1;<br></code></pre></td></tr></table></figure><p></p><p><strong>运算符</strong></p><p>除了没有指针相关的运算符外，其他的与 c 语言完全一致</p><p>注 1：对于向量、矩阵类型，运算符会在各个分量上进行</p><p>注 2：支持浮点数取模 %</p><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs raw">int n1 = 5 % 3;  // 取模即求余数，结果为2<br>float f1 = 3.3 % 1.6; // 3.3-(int)(3.3/1.6)*1.6 = 3.3-2*1.6 = 0.1<br>float f2 = -3.3 % 1.6; // -3.3-(int)(-3.3/1.6)*1.6 = -3.3-(-2*1.6) = -0.1<br></code></pre></td></tr></table></figure><p></p><p>注 3：二元运算中变量类型的提升规则：</p><p>① 对于二元运算来说，如果运算符左右操作数的维度不同，那么维度较小的变量类型将会被隐式提升为维度较大的变量类型。但是这种提升仅限于标量到向量的提升，即 x 会变为 (x, x, x)。但是不支持像 float2 到 float3 的提升。</p><p>② 对于二元运算来说，如果运算符左右的操作数类型不同，那么低精度变量的类型将被隐式提升为高精度变量的类型，这点和 C/C++ 是类似的。</p><hr><h2 id="控制流"><a class="anchor" href="#控制流">#</a> <strong>控制流</strong></h2><h3 id="条件语句"><a class="anchor" href="#条件语句">#</a> <strong>条件语句</strong></h3><p>HLSL 也支持 <code>if</code> , <code>else</code> , <code>continue</code> , <code>break</code> , <code>switch</code> 关键字，此外 <code>discard</code> 关键字用于像素着色阶段抛弃该像素。</p><p>条件的判断使用一个布尔值进行，通常由各种逻辑运算符或者比较运算符操作得到。注意向量之间的比较或者逻辑操作是得到一个存有布尔值的向量，不能够直接用于条件判断，也不能用于 <code>switch</code> 语句。</p><h3 id="判断与动态分支"><a class="anchor" href="#判断与动态分支">#</a> 判断与动态分支</h3><p>基于值的条件分支只有在程序执行的时候被编译好的着色器汇编成两种方式：<strong>判断 (predication)<strong> 和</strong>动态分支 (dynamic branching)</strong>。</p><p>如果使用的是判断的形式，编译器会提前计算两个不同分支下表达式的值。然后使用比较指令来基于比较结果来 &quot;选择&quot; 正确的值。</p><p>而动态分支使用的是跳转指令来避免一些非必要的计算和内存访问。</p><p>着色器程序在同时执行的时候应当选择相同的分支，以防止硬件在分支的两边执行。通常情况下，硬件会同时将一系列连续的顶点数据传入到顶点着色器并行计算，或者是一系列连续的像素单元传入到像素着色器同时运算等。</p><p>动态分支会由于执行分支指令所带来的开销而导致一定的性能损失，因此要权衡动态分支的开销和可以跳过的指令数目。</p><p>通常情况下编译器会自行选择使用判断还是动态分支，但我们可以通过重写某些属性来修改编译器的行为。我们可以在条件语句前可以选择添加下面两个属性之一：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>[branch]</td><td>缺省。根据条件值的结果，只计算其中一边的内容，会产生跳转指令。</td></tr><tr><td>[flatten]</td><td>两边的分支内容都会计算，然后根据条件值选择其中一边。可以避免跳转指令的产生。</td></tr></tbody></table><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs raw">[flatten]<br>if (x)<br>&#123;<br>    x = sqrt(x);<br>&#125;1.2.3.4.5.<br></code></pre></td></tr></table></figure><p></p><h3 id="循环语句"><a class="anchor" href="#循环语句">#</a> <strong>循环语句</strong></h3><p>HLSL 也支持 <code>for</code> , <code>while</code> 和 <code>do while</code> 循环。和条件语句一样，它可能也会在基于运行时的条件值判断而产生动态分支，从而影响程序性能。用法如下：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>[loop]</td><td>缺省。默认不加属性的循环语句为 loop 型。</td></tr><tr><td>[unroll]</td><td>如果循环次数较小，我们可以使用属性 [unroll] 来展开循环，代价是产生更多的汇编指令。</td></tr></tbody></table><p></p><figure class="highlight plaintext"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs raw">times = 4;<br>sum = times;<br>[unroll]<br>while (times--)<br>&#123;<br>    sum += times;<br>&#125;1.2.3.4.5.6.7.<br></code></pre></td></tr></table></figure><p></p><h3 id="寄存器register"><a class="anchor" href="#寄存器register">#</a> <strong>寄存器（register）</strong></h3><p>用于在 C++ 与 HLSL 之间传递数据，包括如下 4 种：</p><table><thead><tr><th>寄存器</th><th>说明</th><th>上限</th></tr></thead><tbody><tr><td>b</td><td>常量缓冲区视图 (CBV)，用于从 C++ 传递只读数据给 HLSL</td><td>15 个常量缓冲区（共 16 个，系统内部保留 1 个）</td></tr><tr><td>t</td><td>着色器资源视图 (SRV)，用于从 C++ 传递只读内存块或纹理数据给 HLSL</td><td>128 个</td></tr><tr><td>u</td><td>无序访问视图 (UAV)，用于可读写数据的传递</td><td></td></tr><tr><td>s</td><td>用于从 C++ 传递采样器设置给 HLSL</td><td>128 个</td></tr></tbody></table><h3 id="变量"><a class="anchor" href="#变量">#</a> <strong>变量</strong></h3><p>变量名需要符合以下规则：</p><p>① 只能包括大小写字母、数字和下划线</p><p>② 变量名不能以数字开头</p><p>③ 不能是关键字或预留的关键字</p><p>全局变量：定义在函数体外的变量。作用域规则与 c 语言全局变量一致。</p><p>局部变量：定义在函数内的变量。作用域规则与 c 语言局部变量一致。</p><p>const 变量</p><p>该变量为一常量，需要被初始化，在运行时不能被修改，与 c/c++ 用法一致</p><p>static 变量</p><p>进一步可分为 static 局部变量和 static 全局变量，与 c/c++ 用法一致</p><p>static 局部变量需要在 HLSL 中自己初始化，否则使用默认初始化，初始化操作仅执行一次（首次被访问时）</p><p>只在着色器内部可见</p><p>extern 变量</p><p>在全局变量上可用，非静态的全局变量默认是 extern 类型</p><p>可在着色器外被访问，比如被 C++ 应用程序</p><p>uniform 变量</p><p>在 D3D 代码中初始化，然后再作为输入传给着色器</p><p>允许在 C++ 应用层中修改，但在着色器执行的过程中，其值始终保持不变（运行前可变，运行时不变）。着色器程序中的全局变量默认为既 uniform 又 extern</p><p>volatile 变量</p><p>表示该变量经常被修改，用于局部变量</p><p>shared 变量</p><p>在全局变量上可用，提示效果框架该变量可在多个效果之间共享</p><p>nointerpolation -- 修饰的变量，在将顶点着色器的输出传递到像素着色器之前，请勿对其进行插值</p><p>groupshared -- 将一个变量标记为用于计算着色器的线程组共享内存</p><p>precise -- 用于保证该变量在计算时，是严格精确的</p><p>row_major -- 标记一个可在单个行中存储 4 个成分的变量，以便可以将它们存储在单个常量寄存器中</p><p>column_major -- 标记一个可在单个列中存储 4 个成分的变量，以优化矩阵数学 （缺省）</p><h3 id="语义"><a class="anchor" href="#语义">#</a> <strong>语义</strong></h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZGhsc2wvZHgtZ3JhcGhpY3MtaGxzbC1zZW1hbnRpY3M=">语义</span>通常是附加在着色器输入 / 输出参数上的字符串。它在着色器程序的用途如下：</p><ol><li>用于描述传递给着色器程序的变量参数的含义</li><li>允许着色器程序接受由渲染管线生成的特殊系统值</li><li>允许着色器程序传递由渲染管线解释的特殊系统值</li></ol><h2 id="vs语义"><a class="anchor" href="#vs语义">#</a> vs 语义</h2><table><thead><tr><th>语义</th><th>描述</th><th>是否可作为输入关联</th><th>是否可作为输出关联</th><th>类型</th></tr></thead><tbody><tr><td>BINORMAL[n]</td><td>副法线（副切线）向量</td><td>Yes</td><td></td><td>float4</td></tr><tr><td>BLENDINDICES[n]</td><td>混合索引</td><td>Yes</td><td></td><td>uint</td></tr><tr><td>BLENDWEIGHT[n]</td><td>混合权重</td><td>Yes</td><td></td><td>float</td></tr><tr><td>COLOR[n]</td><td>漫反射 / 镜面反射颜色</td><td>Yes</td><td>Yes</td><td>float4</td></tr><tr><td>NORMAL[n]</td><td>法向量</td><td>Yes</td><td></td><td>float4</td></tr><tr><td>POSITION[n]</td><td>物体坐标系下的顶点坐标</td><td>Yes</td><td>Yes</td><td>float4</td></tr><tr><td>PSIZE[n]</td><td>点的大小</td><td>Yes</td><td>Yes</td><td>float</td></tr><tr><td>TANGENT[n]</td><td>切线向量</td><td>Yes</td><td></td><td>float4</td></tr><tr><td>TEXCOORD[n]</td><td>纹理坐标</td><td>Yes</td><td>Yes</td><td>float4</td></tr><tr><td>FOG</td><td>顶点雾</td><td></td><td>Yes</td><td>float</td></tr></tbody></table><p>注 1：n 是一个可选的整数，从 0 开始。比如 POSITION0, TEXCOORD1 等等。</p><p>注 2：vs 的输出关联将其运算得到的结果经过光栅化插值后链接到 ps 的输入关联上.</p><h2 id="ps语义"><a class="anchor" href="#ps语义">#</a> <strong>ps 语义</strong></h2><table><thead><tr><th>语义</th><th>描述</th><th>是否可作为输入关联</th><th>是否可作为输出关联</th><th>类型</th></tr></thead><tbody><tr><td>COLOR[n]</td><td>漫反射 / 镜面反射颜色</td><td>Yes</td><td>Yes</td><td>float4</td></tr><tr><td>TEXCOORD[n]</td><td>纹理坐标</td><td>Yes</td><td></td><td>float4</td></tr><tr><td>VFACE</td><td>负数表示为背面</td></tr><tr><td>正数表示为正面</td><td>Yes</td><td></td><td>float</td></tr><tr><td>VPOS</td><td>像素所在坐标</td><td>Yes</td><td></td><td>float2</td></tr><tr><td>DEPTH[n]</td><td>深度值</td><td></td><td>Yes</td><td>float</td></tr></tbody></table><p>注： ps 输出关联将其输出颜色绑定给正确的 RT 上（渲染目标）。其中颜色输出被连接到 alpha 混合阶段，DEPTH 输出关联用于改变当前光栅化位置的目标深度值</p><h2 id="系统值语义"><a class="anchor" href="#系统值语义">#</a> <strong>系统值语义</strong></h2><p>所有的系统值都包含前缀 <code>SV_</code> ，后面的部分大小写不敏感，例如：SV_Positon 和 SV_POSITION 是一样的。这些系统值将用于某些着色器的特定用途。</p><table><thead><tr><th>系统值</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>SV_Depth</td><td>深度缓冲区数据，可以被任何着色器写入 / 读取</td><td>float</td></tr><tr><td>SV_InstanceID</td><td>每个实例都会在运行期间自动生成一个 ID。在任何着色器阶段都能读取</td><td>uint</td></tr><tr><td>SV_IsFrontFace</td><td>指定该三角形是否为正面。可以被几何着色器写入，以及可以被像素着色器读取</td><td>bool</td></tr><tr><td>SV_Position</td><td>若被声明用于输入到着色器，它描述的是像素位置，在所有着色器中都可用，可能会有 0.5 的偏移值</td><td>float4</td></tr><tr><td>SV_PrimitiveID</td><td>每个原始拓扑都会在运行期间自动生成一个 ID。可用在几何 / 像素着色器中写入，也可以在像素 / 几何 / 外壳 / 域着色器中读取</td><td>uint</td></tr><tr><td>SV_StencilRef</td><td>代表当前像素着色器的模板引用值。只可以被像素着色器写入</td><td>uint</td></tr><tr><td>SV_VertexID</td><td>每个实例都会在运行期间自动生成一个 ID。仅允许作为顶点着色器的输入</td><td>uint</td></tr><tr><td>SV_TARGET</td><td>SV_TARGET 即 Color 缓存区（帧缓存，FrameBuffer）</td><td></td></tr><tr><td>SV_TARGET[n] 0 &lt;= n &lt;= 7</td><td>MRT 有多个 RenderTarget 输出</td><td></td></tr><tr><td>SV_ClipDistance0</td><td></td><td></td></tr><tr><td>SV_RenderTargetArrayIndex</td><td></td><td></td></tr><tr><td>SV_TessFactor</td><td></td><td></td></tr><tr><td>SV_InsideTessFactor</td><td></td><td></td></tr><tr><td>SV_DomainLocation</td><td></td><td></td></tr><tr><td>SV_GroupID</td><td></td><td></td></tr><tr><td>SV_GroupIndex</td><td></td><td></td></tr><tr><td>SV_GroupThreadID</td><td></td><td></td></tr><tr><td>SV_DispatchThreadID</td><td></td><td></td></tr></tbody></table><h3 id="着色器常量"><a class="anchor" href="#着色器常量">#</a> <strong>着色器常量</strong></h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZGhsc2wvZHgtZ3JhcGhpY3MtaGxzbC1jb25zdGFudHM=">着色器常量</span>存在内存中的一个或多个缓冲区资源当中。他们可以被组织成两种类型的缓冲区：常量缓冲区（cbuffers）和纹理缓冲区（tbuffers）。</p><h2 id="常量缓冲区constant-buffer"><a class="anchor" href="#常量缓冲区constant-buffer">#</a> <strong>常量缓冲区 (Constant Buffer)</strong></h2><p>常量缓冲区允许 C++ 端将数据传递给 HLSL 中使用，在 HLSL 中，这些传递过来的数据不可更改，因而是常量。常量缓冲区对这种使用方式有所优化，表现为低延迟的访问和允许来自 CPU 的频繁更新，因此他们有额外的大小、布局和访问限制。</p><p>① 每个着色器阶段最多允许 15 个常量缓冲区（共 16 个，系统内部保留 1 个），并且每个缓冲区最多可以容纳 4096 个标量（每个 vector 最多包含 4 个 float 类型）。HLSL 的 cbuffer 需要指定 register (b#), #的范围为 0 到 14</p><p>② 在 C++ 创建常量缓冲区时大小必须为 16 字节的倍数，因为 HLSL 的常量缓冲区本身以及对它的读写操作需要严格按 16 字节对齐</p><p>③ 对常量缓冲区的成员使用 packoffset 修饰符可以指定起始向量和分量位置</p><p>④ 在更新常量缓冲区时由于数据是提交完整的字节流数据到 GPU，会导致 HLSL 中 cbuffer 的所有成员都被更新。为了减少不必要的更新，可以根据这些参数的更新频率划分出多个常量缓冲区以节省带宽资源</p><p>⑤ 一个着色器在使用了多个常量缓冲区的情况下，这些常量缓冲区相互间都不能出现同名成员</p><p>⑥ 单个常量缓冲区可以同时绑定到不同的可编程着色器阶段，因为这些缓冲区都是只读的，不会导致内存访问冲突。</p><p>一个包含常量缓冲区的 *.hlsli 文件同时被多个着色器文件引用，只是说明这些着色器使用相同的常量缓冲区布局，如果该缓冲区需要在多个着色器阶段使用，你还需要在 C++ 同时将相同的常量缓冲区绑定到各个着色器阶段上</p><p>当我们在 HLSL 中声明常量缓冲区时，还<strong>需要在 HLSL 的声明中使用关键字 <code>register</code> 手动指定对应的寄存器索引</strong>，然后编译器会为对应的着色器阶段自动将其映射到 15 个常量缓冲寄存器的其中一个位置。这些寄存器的名字为 <code>b0</code> 到 <code>b14</code> ：</p><p></p><figure class="highlight c++"><figcaption><span>raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/****************************** C++ ******************************/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VS_CONSTANT_BUFFER</span><br>&#123;<br>    D3DXMATRIX mWorldViewProj;<br><br>    D3DXVECTOR4 vSomeVectorThatMayBeNeededByASpecificShader;<br>    <span class="hljs-type">float</span> fSomeFloatThatMayBeNeededByASpecificShader;<br><br>    <span class="hljs-type">float</span> fTime;<br><br>    <span class="hljs-type">float</span> fSomeFloatThatMayBeNeededByASpecificShader2;<br>    <span class="hljs-type">float</span> fSomeFloatThatMayBeNeededByASpecificShader3;<br>&#125;;<br><br><span class="hljs-comment">/***************************** HLSL *****************************/</span><br><span class="hljs-comment">// 在cb0中，第一个 mWorldViewProj : packoffset(c0)表示将会在这个cbuffer中的c0位置开始存储 mWorldViewProj,共使用c0,c1,c2,c3</span><br><span class="hljs-comment">// 由于D3DXVECTOR4 vSomeVectorThatMayBeNeededByASpecificShader占据了c4，float fSomeFloatThatMayBeNeededByASpecificShader占据了c5.x，所以float fTime就是c5.y了</span><br><br><span class="hljs-comment">// 在C++代码层中，D3DXMATRIX矩阵是行矩阵，但当矩阵从C++传递给HLSL时，HLSL默认是列矩阵的，因此传递前要进行了一次转置。如果希望不发生转置操作的话，则需要添加修饰关键字row_major</span><br>cbuffer cb0<br>&#123;<br>    row_major float4x4 mWorldViewProj : <span class="hljs-built_in">packoffset</span>(c0);<br><br>    <span class="hljs-type">float</span> fTime : <span class="hljs-built_in">packoffset</span>(c5.y);<br>&#125;;<span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><span class="hljs-number">.6</span><span class="hljs-number">.7</span><span class="hljs-number">.8</span><span class="hljs-number">.9</span><span class="hljs-number">.10</span><span class="hljs-number">.11</span><span class="hljs-number">.12</span><span class="hljs-number">.13</span><span class="hljs-number">.14</span><span class="hljs-number">.15</span><span class="hljs-number">.16</span><span class="hljs-number">.17</span><span class="hljs-number">.18</span><span class="hljs-number">.19</span><span class="hljs-number">.20</span><span class="hljs-number">.21</span><span class="hljs-number">.22</span><span class="hljs-number">.23</span><span class="hljs-number">.24</span><span class="hljs-number">.25</span><span class="hljs-number">.26</span>.<br></code></pre></td></tr></table></figure><p></p><p>注 1：常量缓冲区（constant buffer views，CBV）用 b 寄存器来传递</p><p>注 2：packoffset (c0) 表示起始位置为 c0，其中 c 为一个 float4 的向量 (x,y,z,w)</p><p>在 C++ 端是通过 ID3D11DeviceContext::VSSetConstantBuffers、ID3D11DeviceContext::PSSetConstantBuffers 指定特定的槽 (slot) 来给某一着色器阶段对应的寄存器索引提供常量缓冲区的数据。</p><p>如果是存在多个不同的着色器阶段使用同一个常量缓冲区，那就需要分别给这两个着色器阶段设置好相同的数据。</p><p>综合前面几节内容，下面演示了顶点着色器和常量缓冲区的用法：</p><p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">cbuffer ConstantBuffer : <span class="hljs-built_in">register</span>(b0)<br>&#123;<br>    float4x4 g_WorldViewProj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VS_Main</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    in float4 inPos : POSITION,         <span class="hljs-comment">// 绑定变量到输入装配器</span></span></span><br><span class="hljs-params"><span class="hljs-function">    in uint VID : SV_VertexID,          <span class="hljs-comment">// 绑定变量到系统生成值</span></span></span><br><span class="hljs-params"><span class="hljs-function">    out float4 outPos : SV_Position)</span>    <span class="hljs-comment">// 告诉管线将该值解释为输出的顶点位置</span></span><br><span class="hljs-function"></span>&#123;<br>    outPos = <span class="hljs-built_in">mul</span>(inPos, g_WorldViewProj);<br>&#125;<span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><span class="hljs-number">.6</span><span class="hljs-number">.7</span><span class="hljs-number">.8</span><span class="hljs-number">.9</span><span class="hljs-number">.10</span><span class="hljs-number">.11</span><span class="hljs-number">.12</span><span class="hljs-number">.13</span>.<br></code></pre></td></tr></table></figure><p></p><p>上面的代码也可以写成：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cbuffer ConstantBuffer : register(b0)<br>&#123;<br>    float4x4 g_WorldViewProj;<br>&#125;<br><br>struct VertexIn<br>&#123;<br>    float4 inPos : POSITION;    // 源自输入装配器<br>    uint VID : SV_VertexID;        // 源自系统生成值<br>&#125;;<br><br>float4 VS_Main(VertexIn vIn) : SV_Position<br>&#123;<br>    return mul(vIn.inPos, g_WorldViewProj);<br>&#125;1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.<br></code></pre></td></tr></table></figure><p></p><h3 id="纹理缓冲区texture-buffer"><a class="anchor" href="#纹理缓冲区texture-buffer">#</a> <strong>纹理缓冲区（Texture Buffer）</strong></h3><p>纹理缓冲区（tbuffer）并不是用来存储纹理的，而是指可以像纹理那样来访问其中的数据，对于索引类数据有更好的性能。这些数据也是只读的。vs、ps 阶段分别最多可以绑定 128 个 tbuffer。</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tbuffer mytb : register(t0)<br>&#123;<br>    float weight[256];        // 可以从CPU更新，只读<br>&#125;<br></code></pre></td></tr></table></figure><p></p><h3 id="有类型的缓冲区typed-buffer"><a class="anchor" href="#有类型的缓冲区typed-buffer">#</a> <strong>有类型的缓冲区 (Typed Buffer)</strong></h3><p>这是一种创建和使用起来最简单的缓冲区，其数据可以在 HLSL 被解释成基本 HLSL 类型的数组形式。</p><p><strong>Buffer（只读的缓冲区类型）</strong></p><p><strong>RWBuffer（可读写的缓冲区类型）</strong></p><p><strong>结构化缓冲区（Struct Buffer）</strong></p><p>StructuredBuffer（只读的结构化缓冲区）</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct TBokeh<br>&#123;<br>    float2 Pos;<br>    float Radius;<br>    float4 Color;<br>&#125;;<br>StructuredBuffer&lt;TBokeh&gt; Bokeh : register( t0 );<br>StructuredBuffer&lt;float&gt; AvgLum : register( t1 );1.2.3.4.5.6.7.8.<br></code></pre></td></tr></table></figure><p></p><p>RWStructuredBuffer（可读写的结构化缓冲区）</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// Single raindrop structure<br>struct RainDrop<br>&#123;<br>    float3 Pos;<br>    float3 Vel;<br>    float State;<br>&#125;;<br><br>// Raindrop buffer<br>RWStructuredBuffer&lt;RainDrop&gt; RainData : register( u0 );<br>RWStructuredBuffer&lt;float&gt; AverageLum : register( u1 );1.2.3.4.5.6.7.8.9.10.11.<br></code></pre></td></tr></table></figure><p></p><h3 id="追加消耗缓冲区appendconsume-buffer"><a class="anchor" href="#追加消耗缓冲区appendconsume-buffer">#</a> <strong>追加 / 消耗缓冲区 (Append/Consume Buffer)</strong></h3><p>追加缓冲区和消耗缓冲区类型实际上是结构化缓冲区的特殊变体资源。因为涉及到修改操作，它们只能使用乱序访问视图（unordered access view，UAV）来绑定，用 u 寄存器来传递。</p><p>如果你只是希望这些结构体数据经过着色器变换并且不需要考虑最终的输出顺序要一致，那么使用这两个缓冲区是一种不错的选择。</p><p>AppendStructuredBuffer</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct TBokeh<br>&#123;<br>    float2 Pos;<br>    float Radius;<br>    float4 Color;<br>&#125;;<br>AppendStructuredBuffer&lt;TBokeh&gt; BokehStack : register( u0 );<br><br>AppendStructuredBuffer&lt;float3&gt; g_VertexOut : register(u1);1.2.3.4.5.6.7.8.<br></code></pre></td></tr></table></figure><p></p><p>ConsumeStructuredBuffer</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ConsumeStructuredBuffer&lt;float3&gt; g_VertexIn : register(u0);<br></code></pre></td></tr></table></figure><p></p><h3 id="字节地址缓冲区byte-address-buffer"><a class="anchor" href="#字节地址缓冲区byte-address-buffer">#</a> <strong>字节地址缓冲区 (Byte Address Buffer)</strong></h3><p>字节地址缓冲区为 HLSL 程序提供了一种更为原始的内存块，程序员自己负责解析内存块的内容</p><p>ByteAddressBuffer（只读的字节地址缓冲区）</p><p>使用着色器资源视图（shader resource views，SRV）来绑定，用 t 寄存器来传递</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ByteAddressBuffer g_ByteAddressBuffer : register(t0);<br></code></pre></td></tr></table></figure><p></p><p>RWByteAddressBuffer（可读写的结构化缓冲区）</p><p>不仅支持写入，还支持原子操作。使用乱序访问视图（unordered access view，UAV）来绑定，用 u 寄存器来传递。</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">RWByteAddressBuffer g_RWByteAddressBuffer : register(u0);<br></code></pre></td></tr></table></figure><p></p><h1 id="基础类型"><a class="anchor" href="#基础类型">#</a> <strong>基础类型</strong></h1><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 布尔型<br>bool b1 = true;<br>bool b2 = 10; // b2=true<br><br>// 32位有符号整型<br>int n1 = 10;<br>int n2 = &#123; -25 &#125;;<br>int n3 = 0;<br>int n4 = 0.9; // 取整数部分  n4=0<br>int n5 = 3L; // n5=3<br>int n6 = 0x14; // 16进制 n6=20<br>int n7 = 027; // 8进制 n7=23<br>int n8 = b1; // n8=1<br><br>// 32位无符号整型<br>uint u1 = 0;<br>uint u2 = 1u;<br>uint u3 = 100L;<br>uint u4 = 1.5;// 取整数部分  u4=1<br>uint u5 = -3.2;// 赋值为负数时  u5=0<br>uint u6 = b1;// u6=1<br><br>// dword类型与uint类型等价<br>dword dw1 = 150;<br>dword dw2 = 0.9;// 取整数部分  dw2=0<br>dword dw3 = -2.8f;// 赋值为负数时  dw3=0<br><br>// 64位双精度浮点型<br>double d1 = 200UL;<br>double d2 = dw1;<br>double d3 = 20.8f;<br>double d4 = 320.5;<br><br>// 32位单精度浮点型<br>float f1 = -250.6;<br>float f2 = 130.0f;<br>float f3 = d3;<br><br>// 16位单精度浮点型<br>half h1 = 1.0f;<br>half h2 = n6; // h2=20<br>half h3 = d4; // h3=320.5<br>half h4 = f2; // h4=130.0f<br>half h5 = f1 + d1; // h5=-50.6<br><br>// 基础类型强制转换<br>bool b3 = bool(n3); // b3=false  支持c类型的转换方式<br>int n9 = int(f1); // n9=-250  支持c类型的转换方式<br>uint u7 = (uint)f1; // u7=0<br>uint u8 = (uint)d3; // u8=201.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31.32.33.34.35.36.37.38.39.40.41.42.43.44.45.46.47.48.49.50.<br></code></pre></td></tr></table></figure><p></p><p>注：有些平台可能不支持 int、half 和 double，这种情况下，这些类型将用 float 来模拟</p><h2 id="数组"><a class="anchor" href="#数组">#</a> <strong>数组</strong></h2><p>除了一维数组外，允许有多维数组</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">float fa1[5]; // fa1 = &#123;0.0, 0.0, 0.0, 0.0, 0.0&#125;<br>int ia1[3] = &#123; 1 ,2 ,3 &#125;;<br>uint ua1[2][3] = &#123; &#123;2, 3, 5&#125;,&#123;4, 8, 7&#125; &#125;;<br>vector va1[2] = &#123; &#123;0.1, 0.2, 0.13, 0.0&#125;, &#123;1.0, 0.0, 2.0, 1.0&#125; &#125;;<br>float1x2 ma1[2] = &#123; &#123;2.0, 4.0&#125;, &#123;0.5, 0.6&#125; &#125;;1.2.3.4.5.<br></code></pre></td></tr></table></figure><p></p><h2 id="结构体struct"><a class="anchor" href="#结构体struct">#</a> <strong>结构体（struct）</strong></h2><p>① 可从其他结构体上派生</p><p>② 与 C 语言结构体一样，不允许有构造函数和析构函数</p><p>③ 不能直接对 2 个结构体变量进行比较</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct base &#123; float param; &#125;;<br><br>struct light : base // 可从另外一个结构体上继承<br>&#123;<br>    vector color;<br>    float3 position;<br><br>    //light()&#123;&#125; // 与C语言一样，不允许有构造函数<br>    //~light()&#123;&#125; // 与C语言一样，不允许有析构函数<br><br>    void test()<br>    &#123;<br>        param = 0.5;<br>        color.x = 0.2;<br>    &#125;<br>&#125;;<br><br>//base s1 = base(2.5); //编译错误 error X3037: constructors only defined for numeric base types<br>//light s2 = light(2.1, vector(1.0, 1.0, 0.0, 1.0), float3(10.0, 10.0, 0.0));//编译错误 error X3037: constructors only defined for numeric base types<br>light s3, s4;<br>//if (s3 == s4) &#123;&#125;// 结构体不能直接比较  编译错误 error X3020 : type mismatch<br><br>s3.test();1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.<br></code></pre></td></tr></table></figure><p></p><h2 id="向量"><a class="anchor" href="#向量">#</a> <strong>向量</strong></h2><p>向量的分量可以为：</p><p>① {x,y,z,w} ： 用来获取顶点坐标分量</p><p>② {r,g,b,a} ： 用来获取颜色分量</p><p>从向量中可以同时抽取多个分量，这个过程称作混合（swizzle，或重组、重排）。但要注意地是，以上两种不能相互混着使用，如：xyr、rgyz 等</p><table><thead><tr><th>分量类型</th><th>1 维</th><th>2 维</th><th>3 维</th><th>4 维</th></tr></thead><tbody><tr><td>bool</td><td>bool1 // vector&lt;bool,1&gt;</td><td>bool2 // vector&lt;bool,2&gt;</td><td>bool3 // vector&lt;bool,3&gt;</td><td>bool4 // vector&lt;bool,4&gt;</td></tr><tr><td>int</td><td>int1 // vector&lt;int,1&gt;</td><td>int2 // vector&lt;int,2&gt;</td><td>int3 // vector&lt;int,3&gt;</td><td>int4 // vector&lt;int,4&gt;</td></tr><tr><td>uint</td><td>uint1 // vector&lt;uint,1&gt;</td><td>uint2 // vector&lt;uint,2&gt;</td><td>uint3 // vector&lt;uint,3&gt;</td><td>uint4 // vector&lt;uint,4&gt;</td></tr><tr><td>half</td><td>half1 // vector&lt;half,1&gt;</td><td>half2 // vector&lt;half,2&gt;</td><td>half3 // vector&lt;half,3&gt;</td><td>half4 // vector&lt;half,4&gt;</td></tr><tr><td>float</td><td>float1 // vector&lt;float,1&gt;</td><td>float2 // vector&lt;float,2&gt;</td><td>float3 // vector&lt;float,3&gt;</td><td>float4 //vector&lt;float,4&gt; 即 vector</td></tr><tr><td>double</td><td>double1 // vector&lt;double,1&gt;</td><td>double2 // vector&lt;double,2&gt;</td><td>double3 // vector&lt;double,3&gt;</td><td>double4 // vector&lt;double,4&gt;</td></tr></tbody></table><p>注 1：vector 为一个 4 维向量，各元素的类型为 float</p><p>注 2：vector&lt;T, n&gt; 为一个 n 维向量（n 必须介于 1~4 之间），各元素的类型为 T</p><p>注 3：当 N&gt;n 时，可裁剪降维后自动隐式转换 N --&gt; n</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// 向量 vector为4维float类型向量<br>vector v1 = &#123; 0.0, 1.0, 0.0, 0.0 &#125;;<br>vector v2; // v2 = &#123; 0.0, 0.0, 0.0, 0.0 &#125;<br>v2[0] = 1.0; // v2 = &#123; 1.0, 0.0, 0.0, 0.0 &#125;<br>v2.z = 1.0; // v2 = &#123; 1.0, 0.0, 1.0, 0.0 &#125;<br>v2.g = 1.0; // v2 = &#123; 1.0, 1.0, 1.0, 0.0 &#125;<br><br>// 混合（swizzle）<br>vector v3 = v1.yzwx; // v3 = &#123; 1.0, 0.0, 0.0, 0.0 &#125; 等价于 v3.x=v1.y; v3.y=v1.z; v3.z=v1.w; v3.w=v1.x;<br>vector v4 = v1.rbga; // v4 = &#123; 0.0, 0.0, 1.0, 0.0 &#125;  等价于 v4.x=v1.r; v4.y=v1.b; v4.z=v1.g; v4.w=v1.a;<br>vector v5 = vector(0.5, 0.2, 1.0, 0.0); // v5 = &#123; 0.5, 0.2, 1.0, 0.0 &#125;  新构造方法<br>v5.xz = v1; // v5 = &#123; 0.0, 0.2, 0.0, 0.0 &#125;  只将v1的xz分量赋值给v5，等价于 v5.x=v1.x; v5.z=v1.z;<br><br>//vector v6 = vector(0.95); // 编译错误  error X3014: incorrect number of arguments to numeric-type constructor<br>vector v6 = (vector)0.95; // v6 = &#123; 0.95, 0.95, 0.95, 0.95 &#125;<br><br>vector&lt;float, 4&gt; v7 = v1; // vector&lt;float, 4&gt;即vector类型  v7 = &#123; 0.0, 1.0, 0.0, 0.0 &#125;<br><br>// 向量运算<br>vector v8 = &#123; 0.2, -0.8, 0.3, 0.6 &#125;;<br>vector v9 = &#123; 0.0, 0.5, 1.0, 0.2 &#125;;<br>vector v10 = v8 * 2; // v10 = &#123;0.4, -1.6, 0.6, 1.2&#125;<br>vector v11 = v8 + 0.6; // v11 = &#123;0.8, -0.2, 0.9, 1.2&#125;<br>vector v12 = v8 + v9; // v12 = &#123; 0.2, -0.3, 1.3, 0.8 &#125;<br>vector v13 = v8 * v9; // v13 = &#123;0.0, -0.4, 0.3, 0.12&#125;<br><br>// 逐分量进行比较<br>vector&lt;bool, 4&gt; v14 = (v8 &gt; v9); // v14 = &#123;true, false, false, true&#125;<br><br>// 点乘(内积)<br>float ret1 = dot(v8, v9); // 0.2*0.0+(-0.8)*0.5+0.3*1.0+0.6*0.2 = 0.02<br>// 叉乘(外积)  3维向量特有<br>vector&lt;float, 3&gt; vf3Ret = cross(v8.xyz, v9.xyz); // vf3Ret.x=v8.y*v9.z-v8.z*v9.y = -0.8*1.0-0.3*0.5   = -0.95<br>                                                 // vf3Ret.y=v8.z*v9.x-v8.x*v9.z = 0.3*0.0-0.2*1.0    = -0.2<br>                                                 // vf3Ret.z=v8.x*v9.y-v8.y*v9.x = 0.2*0.5-(-0.8)*0.0 = 0.1<br><br>vector&lt;int, 3&gt; vi3a; // vi3a = &#123;0, 0, 0&#125;<br>vi3a.b = 10;  // vi3a = &#123;0, 0, 10&#125;<br><br>vector&lt;bool, 2&gt; vb2a; // vb2a = &#123;false, false&#125;<br>vb2a.x = true; // vb2a = &#123;true, false&#125;<br><br>// float4即vector<br>float4 vf4a; // vf4a = &#123; 0.0, 0.0, 0.0, 0.0 &#125;<br>vf4a = v2; // vf4a = &#123; 1.0, 1.0, 1.0, 0.0 &#125;<br><br>float1 vf1a = 0.75; // float3即vector&lt;float,1&gt; 即float类型<br>float f1 = vf1a; // f1为0.75<br>float f2 = vf1a.x; // f2为0.75<br>float f3 = vf1a.r; // f3为0.75<br><br>float2 vf2a = &#123; 0.8, 0.9 &#125;; // float2即vector&lt;float,2&gt;<br>float3 vf3a = &#123; 0.2, 0.35, 0.5 &#125;; // float3即vector&lt;float,3&gt;<br>float3 vf3b; // vf3b = &#123; 0.0, 0.0, 0.0 &#125;<br><br>//vf3b = vf2a; // error 编译错误  低维向量不允许赋值给高维向量<br>float2 vf2b = vf3a; // vf2b = &#123; 0.2, 0.35 &#125; 当N&gt;n时，可裁剪降维后自动隐式转换   N --&gt; n<br>vf3b = float3(vf2a, 1.0); // vf3b = &#123; 0.8, 0.9, 1.0 &#125;<br>vf3b = float3(0.3, vf2a); // vf3b = &#123; 0.3, 0.8, 0.9 &#125;<br>vf3b = float3(vf1a, vf2a); // vf3b = &#123; 0.75, 0.8, 0.9 &#125;<br>vf3b = v1;  // vf3b = &#123; 0.0, 1.0, 0.0 &#125;;  高维向量可赋值给低维向量  后面的部分会被截断<br><br>float4 vf4b = &#123; vf2a, vf2a &#125;; // vf4b = &#123; 0.8, 0.9, 0.8, 0.9 &#125;<br>float4 vf4c = &#123; 0.7, vf2a, 0.5 &#125;; // vf4c = &#123; 0.7, 0.8, 0.9, 0.5 &#125;<br>float4 vf4d = &#123; 0.7, vf3a &#125;; // vf4d = &#123; 0.7, 0.2, 0.35, 0.5 &#125;<br><br>bool2 vb2b; // bool2即vector&lt;bool,2&gt;<br>int2 vi2a; // int2即vector&lt;int,2&gt;<br>uint2 vu2a; // uint2即vector&lt;uint,2&gt;<br>// dword2 vdw2a; // error 编译错误  不存在dword2类型<br>half2 vh2a; // half2即vector&lt;half,2&gt;<br>double2 vd2a; // double2即vector&lt;double,2&gt;<br>vf2a = vb2b;<br>vf2a = vi2a;<br>vf2a = vu2a;<br>vf2a = vh2a;<br>vf2a = vd2a;1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31.32.33.34.35.36.37.38.39.40.41.42.43.44.45.46.47.48.49.50.51.52.53.54.55.56.57.58.59.60.61.62.63.64.65.66.67.68.69.70.71.72.73.74.75.76.77.<br></code></pre></td></tr></table></figure><p></p><h2 id="矩阵"><a class="anchor" href="#矩阵">#</a> <strong>矩阵</strong></h2><p>按照行优先顺序来存储（行主序）</p><table><thead><tr><th>分量类型</th><th>matrix 类型</th><th>m x n //m 行 n 列</th></tr></thead><tbody><tr><td>bool</td><td>matrix&lt;bool, m, n&gt;</td><td>bool1x1、bool1x2、bool1x3、bool1x4……</td></tr><tr><td>int</td><td>matrix&lt;int, m, n&gt;</td><td>int1x1、int1x2、int1x3、int1x4</td></tr><tr><td>uint</td><td>matrix&lt;uint, m, n&gt;</td><td>uint1x1、uint1x2、uint1x3、uint1x4</td></tr><tr><td>half</td><td>matrix&lt;half, m, n&gt;</td><td>half1x1、half1x2、half1x3、half1x4</td></tr><tr><td>float</td><td>matrix&lt;float, m, n&gt;</td><td>float1x1、float1x2、float1x3、float1x4</td></tr><tr><td>注：matrix 即为 float4x4</td></tr><tr><td>double</td><td>matrix&lt;double, m, n&gt;</td><td>double1x1、double1x2、double1x3、double1x4</td></tr></tbody></table><p>注 1：matrix 为一个 4x4 float 矩阵</p><p>注 2：matrix&lt;T, m, n&gt; 为一个 m x n（m、n 必须介于 1~4 之间），各元素的类型为 T</p><p>注 3：当 M&gt;m 且 N&gt;n 时，可裁剪降维后自动隐式转换 M x N --&gt; m x n</p><p></p><figure class="highlight plaintext"><figcaption><span>hlsl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Hlsl">float2 f2a = &#123; 1.6, 1.8 &#125;;<br>float3 f3a = &#123; 0.0, -1.0, 3.0 &#125;;<br>float2x2 m2x2a; // m2x2a = &#123;0.0, 0.0, 0.0, 0.0&#125;<br>float2x2 m2x2b = &#123; 0.8, 0.6, 2.0, 0.9 &#125;; // m2x2b = &#123;0.8, 0.6, 2.0, 0.9&#125;<br>                                         //          | 0.8  0.6 |<br>                                         //          | 2.0  0.9 |<br>float2x2 m2x2c = float2x2( f3a, 0.1 ); // m2x2c = &#123;0.0, -1.0, 3.0, 0.1&#125;<br>                                       //          | 0.0  -1.0 |<br>                                       //          | 3.0   0.1 |<br>//float2x2 m2x2d = float2x2(f2a, f3a);  // 编译出错  error X3014: incorrect number of arguments to numeric-type constructor<br>float2x2 m2x2e = float2x2(f2a, f3a.xz); // m2x2e = &#123;1.6, 1.8, 0.0, 3.0&#125;<br>                                        //          | 1.6  1.8 |<br>                                        //          | 0.0  3.0 |<br>//float2x2 m2x2f = float2x2(5.0); // 编译出错  error X3014: incorrect number of arguments to numeric-type constructor<br>float2x2 m2x2g = (float2x2)5.0; // m2x2g = &#123;5.0, 5.0, 5.0, 5.0&#125;<br>                                //          | 5.0  5.0 |<br>                                //          | 5.0  5.0 |<br><br>float2 f2b = m2x2b[0]; // 获取m2x2b的第1个行向量  f2b = &#123;0.8  0.6&#125;<br>float2 f2c = m2x2b[1]; // 获取m2x2b的第2个行向量  f2c = &#123;2.0  0.9&#125;<br><br>float f1 = m2x2b[0][1]; // 获取m2x2b的第1行第2列元素 f1 = 0.6<br>float f2 = m2x2b[0].y; // 获取m2x2b的第1行第2列元素 f2 = 0.6<br>float f3 = m2x2b[0].g; // 获取m2x2b的第1行第2列元素 f3 = 0.6<br>float f4 = m2x2b._m01; // 获取m2x2b的第1行第2列元素 f4 = 0.6<br>float f5 = m2x2b._12; // 获取m2x2b的第1行第2列元素 f5 = 0.6<br>float2 f2d = m2x2e._11_22 // 获取m2x2e的第1行第1列元素及第2行第2列元素 Swizzle f2d = &#123;1.6  3.0&#125;<br>m2x2e._12_21 = m2x2e._21_12; // 交换m2x2e[0][1]和m2x2e[1][0] Swizzle<br>                             // m2x2e = &#123;1.6, 0.0, 1.8, 3.0&#125;<br>                             //          | 1.6  0.0 |<br>                             //          | 1.8  3.0 |<br>m2x2e._m00_m11 = m2x2e._m11_m00;    // 交换M[0][0]和M[1][1]     Swizzle<br>                             // m2x2e = &#123;3.0, 0.0, 1.8, 1.6&#125;<br>                             //          | 3.0  0.0 |<br>                             //          | 1.8  1.6 |<br><br>float2x2 m2x2h = m2x2b + m2x2c; // m2x2h = &#123;0.8, -0.4, 5.0, 1.0&#125;<br>float2x2 m2x2i = m2x2b * m2x2c; // m2x2i = &#123;0.0, -0.6, 6.0, 0.09&#125;<br>float2x2 m2x2j = m2x2b + 0.2; // m2x2j = &#123;1.0, 0.8, 2.2, 1.1&#125;<br>float2x2 m2x2k = m2x2b * 2; // m2x2k = &#123;1.6, 1.2, 4.0, 1.8&#125;<br>//float2x2 m2x2l = f2a + m2x2b; // 编译错误  error X3020: type mismatch<br>//float2x2 m2x2m = f2a * m2x2b; // 编译错误  error X3020: type mismatch<br><br>float2x1 m2x1a = &#123; 1.0, 0.2 &#125;; // m2x1a = &#123; 1.0, 0.2 &#125;<br>                               //          | 1.0 |<br>                               //          | 0.2 |<br>float1x2 m1x2a = &#123; 0.3, 1.0 &#125;; // m1x2a = &#123; 0.3, 1.0 &#125;<br>                               //         | 0.3  1.0 |<br>// 矩阵算术运算  M x N --&gt; m x n   注：当M&gt;m且N&gt;n时，可裁剪降维后自动隐式转换<br>float2x1 m2x1b = f2a + m2x1a; // float2向量可与float2x1矩阵进行算术运算<br>                              // m1x2b = &#123; 2.6, 2.0 &#125;<br>                              //           | 2.6 |<br>                              //           | 2.0 |<br>float1x1 m1x1a = &#123; 0.2 &#125;; // | 0.2 |<br>float3x3 m3x3a = &#123;0.1, 0.0, 0.2, 0.15, -0.1, 0.0, -0.2, 0.0, 0.3&#125;;<br>                   // | 0.1   0.0  0.2 |<br>                   // | 0.15 -0.1  0.0 |<br>                   // | -0.2  0.0  0.3 |<br>//float2x2 m2x2n = m2x2b + m2x1a; // 编译错误  error X3017: cannot implicitly convert from &#x27;const float2x1&#x27; to &#x27;float2x2&#x27;<br>float2x1 m2x1c = m2x2b + m2x1a; // m1x2c = &#123; 1.8, 0.8 &#125;<br>float2x2 m2x2o = m2x2b + m1x1a; // m2x2o = &#123;1.0, 0.8, 2.2, 1.1&#125;  注：m1x1a退化为float<br>float2x2 m2x2p = m2x2b + m3x3a; // m2x2p = &#123;0.9, 0.6, 2.15, 0.8&#125;<br>//float3x3 m3x3b = m3x3a + m2x2b; // 编译错误 error X3017 : cannot implicitly convert from &#x27;const float2x2&#x27; to &#x27;float3x3&#x27;<br>//float3x3 m3x3c = m2x2b + m3x3a; // 编译错误 error X3017 : cannot implicitly convert from &#x27;const float2x2&#x27; to &#x27;float3x3&#x27;<br><br>// 矩阵-矩阵乘法<br>float1x1 m1x1b = mul(m1x2a, m2x1a); //                  | 1.0 |<br>                                    // | 0.3  1.0 | mul | 0.2 | = 0.5<br><br>float2x2 m2x2r = mul(m2x1a, m1x2a);//  | 1.0 |                    | 0.3  1.0 |<br>                                    // | 0.2 | mul | 0.3  1.0 | = | 0.06 0.2 |<br><br>// 矩阵右乘向量<br>float2x1 m2x1d = mul(m2x2b, f2a);  // f2a被当成列向量<br>                                   //  | 0.8  0.6 |     | 1.6 |   | 2.36 |<br>                                    // | 2.0  0.9 | mul | 1.8 | = | 4.82 |<br><br>// 矩阵左乘向量<br>float1x2 m1x2b = mul(f2a, m2x2b);  // f2a被当成行向量<br>                                   //                   | 0.8  0.6 |<br>                                   //  | 1.6  1.8 | mul | 2.0  0.9 | = | 4.88 2.58 |1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23.24.25.26.27.28.29.30.31.32.33.34.35.36.37.38.39.40.41.42.43.44.45.46.47.48.49.50.51.52.53.54.55.56.57.58.59.60.61.62.63.64.65.66.67.68.69.70.71.72.73.74.75.76.77.78.79.80.81.82.<br></code></pre></td></tr></table></figure><p></p><h2 id="纹理texture"><a class="anchor" href="#纹理texture">#</a> <strong>纹理（texture）</strong></h2><p>在 glsl、CG 或 Effects Framework（效果框架）中引用纹理，只需要声明一个 sampler2D。</p><p>而在 HLSL 中，sampler2D 这个对象则被拆分为两部分：即 Texture2D（纹理）和 SamplerState（采样器），需要同时声明两个变量来保存它们。</p><p><strong>纹理</strong></p><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Texture1D</td><td>1D 纹理</td><td>RWTexture1D&lt;float&gt; tex;</td></tr><tr><td>Texture1DArray</td><td>1D 纹理数组</td><td>RWTexture1DArray&lt;float&gt; tex;</td></tr><tr><td>Texture2D</td><td>2D 纹理</td></tr><tr><td>Texture2DArray</td><td>2D 纹理数组</td><td>Texture2DArray&lt;float&gt; CascadeShadowMapTexture : register( t4 );</td></tr><tr><td>RWTexture2DArray&lt;float&gt; tex;</td></tr><tr><td>Texture3D</td><td>3D 纹理</td><td>RWTexture3D&lt;float&gt; tex;</td></tr><tr><td>Texture2DMS</td><td></td><td></td></tr><tr><td>Texture2DMSArray</td><td></td><td></td></tr><tr><td>TextureCube</td><td></td><td>TextureCube&lt;float&gt; PointShadowMapTexture : register( t4 );</td></tr><tr><td>TextureCubeArray</td><td></td><td></td></tr></tbody></table><p></p><figure class="highlight yaml"><figcaption><span>Texture2D示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Texture2D DiffuseTexture    :</span> <span class="hljs-string">register(</span> <span class="hljs-string">t0</span> <span class="hljs-string">);</span><br><span class="hljs-string">Texture2D&lt;float&gt;</span> <span class="hljs-attr">DepthTexture         :</span> <span class="hljs-string">register(</span> <span class="hljs-string">t1</span> <span class="hljs-string">);</span><br><span class="hljs-string">Texture2D&lt;float4&gt;</span> <span class="hljs-attr">ColorSpecIntTexture :</span> <span class="hljs-string">register(</span> <span class="hljs-string">t2</span> <span class="hljs-string">);</span><br><span class="hljs-string">Texture2D&lt;float3&gt;</span> <span class="hljs-attr">NormalTexture       :</span> <span class="hljs-string">register(</span> <span class="hljs-string">t3</span> <span class="hljs-string">);</span><br><span class="hljs-string">Texture2D&lt;float4&gt;</span> <span class="hljs-attr">SpecPowTexture      :</span> <span class="hljs-string">register(</span> <span class="hljs-string">t4</span> <span class="hljs-string">);</span><br><br><span class="hljs-string">RWTexture2D&lt;float4&gt;</span> <span class="hljs-attr">MyTexture :</span> <span class="hljs-string">register(</span> <span class="hljs-string">u0</span> <span class="hljs-string">);</span><br><span class="hljs-string">•</span> <span class="hljs-number">1</span><span class="hljs-string">.</span><br><span class="hljs-string">•</span> <span class="hljs-number">2</span><span class="hljs-string">.</span><br><span class="hljs-string">•</span> <span class="hljs-number">3</span><span class="hljs-string">.</span><br><span class="hljs-string">•</span> <span class="hljs-number">4</span><span class="hljs-string">.</span><br><span class="hljs-string">•</span> <span class="hljs-number">5</span><span class="hljs-string">.</span><br><span class="hljs-string">•</span> <span class="hljs-number">6</span><span class="hljs-string">.</span><br><span class="hljs-string">•</span> <span class="hljs-number">7</span><span class="hljs-string">.</span> <span class="hljs-string">|</span><br></code></pre></td></tr></table></figure><br>注 1：只读纹理使用着色器资源视图（shader resource views，SRV）来绑定，用 t 寄存器来传递<p></p><p>注 2：可读写纹理使用乱序访问视图（unordered access view，UAV）来绑定，用 u 寄存器来传递 UnorderedAccessView</p><h2 id="采样器"><a class="anchor" href="#采样器">#</a> <strong>采样器</strong></h2><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>SamplerState</td><td>贴图采样器</td><td>SamplerState LinearSampler : register( s0 );</td></tr><tr><td>SamplerComparisonState</td><td>阴影贴图采样器</td></tr></tbody></table><p>/////////////////////////////////////////////////////////////////////////////<br>// Shadow sampler<br>/////////////////////////////////////////////////////////////////////////////<br>SamplerComparisonState PCFSampler : register( s2 );<br>• 1.<br>• 2.<br>• 3.<br>• 4. |</p><p>注：采样器（sampler）用 s 寄存器来传递</p><h2 id="示例"><a class="anchor" href="#示例">#</a> <strong>示例</strong></h2><p>在 C++ 端是通过 ID3D11DeviceContext::VSSetShaderResources、ID3D11DeviceContext::PSSetShaderResources 指定特定的槽 (slot) 来给某一着色器阶段对应的寄存器索引提供纹理数据。</p><p>在 C++ 端是通过 ID3D11DeviceContext::VSSetSamplers、ID3D11DeviceContext::PSSetSamplers 指定特定的槽 (slot) 来给某一着色器阶段对应的寄存器索引提供 SamplerState 数据。</p><p>当 SamplerState 不需要 C++ 动态传入时，也可以在 hlsl 内部定义</p><p></p><figure class="highlight c++"><figcaption><span>""</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/****************************** C++ ******************************/</span><br>ID3D11ShaderResourceView*   g_pTexture1 = <span class="hljs-literal">NULL</span>;<br>ID3D11ShaderResourceView*   g_pTexture2 = <span class="hljs-literal">NULL</span>;<br>ID3D11SamplerState*         g_pSampLinear = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// PCF sampler state for shadow mapping</span><br>ID3D11SamplerState*         g_pPCFSamplerState = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// Create Shader Resouce View (Texture2D)</span><br>WCHAR str[MAX_PATH];<br><span class="hljs-built_in">V_RETURN</span>( <span class="hljs-built_in">DXUTFindDXSDKMediaFileCch</span>( str, MAX_PATH, <span class="hljs-string">L&quot;..\\Media\\Bokeh1.dds&quot;</span> ) );<br><span class="hljs-built_in">V_RETURN</span>( <span class="hljs-built_in">D3DX11CreateShaderResourceViewFromFile</span>( g_pDevice, str, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;g_pTexture1, <span class="hljs-literal">NULL</span> ) ); <span class="hljs-comment">// ID3D11Device* g_pDevice;</span><br><span class="hljs-built_in">V_RETURN</span>( <span class="hljs-built_in">DXUTFindDXSDKMediaFileCch</span>( str, MAX_PATH, <span class="hljs-string">L&quot;..\\Media\\Bokeh2.dds&quot;</span> ) );<br><span class="hljs-built_in">V_RETURN</span>( <span class="hljs-built_in">D3DX11CreateShaderResourceViewFromFile</span>( g_pDevice, str, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;g_pTexture2, <span class="hljs-literal">NULL</span> ) ); <span class="hljs-comment">// ID3D11Device* g_pDevice;</span><br><br><span class="hljs-comment">// Set Shader Resources</span><br>ID3D11ShaderResourceView* arrViews[<span class="hljs-number">2</span>] = &#123; g_pTexture1, g_pTexture2&#125;;<br>pd3dImmediateContext-&gt;<span class="hljs-built_in">PSSetShaderResources</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, arrViews);<span class="hljs-comment">// ID3D11DeviceContext* pd3dImmediateContext</span><br><br><span class="hljs-comment">// --------------------------------------------------------------</span><br><br><span class="hljs-comment">// Create sampler</span><br>D3D11_SAMPLER_DESC samDesc;<br><span class="hljs-built_in">ZeroMemory</span>( &amp;samDesc, <span class="hljs-built_in">sizeof</span>(samDesc) );<br>samDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;<br>samDesc.AddressU = samDesc.AddressV = samDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;<br>samDesc.MaxAnisotropy = <span class="hljs-number">1</span>;<br>samDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;<br>samDesc.MaxLOD = D3D11_FLOAT32_MAX;<br><span class="hljs-built_in">V_RETURN</span>( pd3dDevice-&gt;<span class="hljs-built_in">CreateSamplerState</span>( &amp;samDesc, &amp;g_pSampLinear ) );<br><br><span class="hljs-comment">// Create the PCF sampler state</span><br>D3D11_SAMPLER_DESC samDesc2;<br><span class="hljs-built_in">ZeroMemory</span>( &amp;samDesc2, <span class="hljs-built_in">sizeof</span>(samDesc2) );<br>samDesc2.Filter = D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR;<br>samDesc2.AddressU = samDesc2.AddressV = samDesc2.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;<br>samDesc2.MaxAnisotropy = <span class="hljs-number">1</span>;<br>samDesc2.ComparisonFunc = D3D11_COMPARISON_LESS_EQUAL;<br>samDesc2.MaxLOD = D3D11_FLOAT32_MAX;<br><span class="hljs-built_in">V_RETURN</span>( g_pDevice-&gt;<span class="hljs-built_in">CreateSamplerState</span>( &amp;samDesc2, &amp;g_pPCFSamplerState ) );<br><br><span class="hljs-comment">// Set render resources</span><br>pd3dImmediateContext-&gt;<span class="hljs-built_in">PSSetSamplers</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;g_pSampLinear ); <span class="hljs-comment">// ID3D11DeviceContext* pd3dImmediateContext</span><br><br><span class="hljs-comment">// Set the shadowmapping PCF sampler</span><br>pd3dImmediateContext-&gt;<span class="hljs-built_in">PSSetSamplers</span>( <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, &amp;g_pPCFSamplerState ); <span class="hljs-comment">// ID3D11DeviceContext* pd3dImmediateContext</span><br><br><span class="hljs-comment">/***************************** HLSL *****************************/</span><br><br><span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Diffuse texture and linear sampler</span><br><span class="hljs-comment">/////////////////////////////////////////////////////////////////////////////</span><br>Texture2D    Diffuse1Texture : <span class="hljs-built_in">register</span>( t0 );<br>Texture2D    Diffuse2Texture : <span class="hljs-built_in">register</span>( t1 );<br>SamplerState LinearSampler : <span class="hljs-built_in">register</span>( s0 );<br><br>SamplerComparisonState PCFSampler : <span class="hljs-built_in">register</span>( s2 );<br><br><span class="hljs-comment">// sampler define in shader code</span><br>SamplerState MeshTextureSampler<br>&#123;<br>    Filter = MIN_MAG_MIP_LINEAR;<br>    AddressU = Wrap;<br>    AddressV = Wrap;<br>&#125;;<br><br><span class="hljs-function">float4 <span class="hljs-title">AmbientLightPS</span><span class="hljs-params">( VS_OUTPUT In )</span> : SV_TARGET0  // VS_OUTPUT In：VS的输出经过光栅化插值后，会作为输入传入PS</span><br><span class="hljs-function">&#123;</span><br>    <span class="hljs-comment">// Sample the texture and convert to linear space</span><br>    float4 Diffuse1Color =  Diffuse1Texture.<span class="hljs-built_in">Sample</span>( LinearSampler, In.UV );<br>    float4 Diffuse2Color =  Diffuse2Texture.<span class="hljs-built_in">Sample</span>( LinearSampler, In.UV );<br><br>    <span class="hljs-comment">// ... ...</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float4</span>((Diffuse1Color+Diffuse2Color).rgb, <span class="hljs-number">1.0</span>);<br>&#125;<span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><span class="hljs-number">.6</span><span class="hljs-number">.7</span><span class="hljs-number">.8</span><span class="hljs-number">.9</span><span class="hljs-number">.10</span><span class="hljs-number">.11</span><span class="hljs-number">.12</span><span class="hljs-number">.13</span><span class="hljs-number">.14</span><span class="hljs-number">.15</span><span class="hljs-number">.16</span><span class="hljs-number">.17</span><span class="hljs-number">.18</span><span class="hljs-number">.19</span><span class="hljs-number">.20</span><span class="hljs-number">.21</span><span class="hljs-number">.22</span><span class="hljs-number">.23</span><span class="hljs-number">.24</span><span class="hljs-number">.25</span><span class="hljs-number">.26</span><span class="hljs-number">.27</span><span class="hljs-number">.28</span><span class="hljs-number">.29</span><span class="hljs-number">.30</span><span class="hljs-number">.31</span><span class="hljs-number">.32</span><span class="hljs-number">.33</span><span class="hljs-number">.34</span><span class="hljs-number">.35</span><span class="hljs-number">.36</span><span class="hljs-number">.37</span><span class="hljs-number">.38</span><span class="hljs-number">.39</span><span class="hljs-number">.40</span><span class="hljs-number">.41</span><span class="hljs-number">.42</span><span class="hljs-number">.43</span><span class="hljs-number">.44</span><span class="hljs-number">.45</span><span class="hljs-number">.46</span><span class="hljs-number">.47</span><span class="hljs-number">.48</span><span class="hljs-number">.49</span><span class="hljs-number">.50</span><span class="hljs-number">.51</span><span class="hljs-number">.52</span><span class="hljs-number">.53</span><span class="hljs-number">.54</span><span class="hljs-number">.55</span><span class="hljs-number">.56</span><span class="hljs-number">.57</span><span class="hljs-number">.58</span><span class="hljs-number">.59</span><span class="hljs-number">.60</span><span class="hljs-number">.61</span><span class="hljs-number">.62</span><span class="hljs-number">.63</span><span class="hljs-number">.64</span><span class="hljs-number">.65</span><span class="hljs-number">.66</span><span class="hljs-number">.67</span><span class="hljs-number">.68</span><span class="hljs-number">.69</span><span class="hljs-number">.70</span><span class="hljs-number">.71</span><span class="hljs-number">.72</span><span class="hljs-number">.73</span><span class="hljs-number">.74</span><span class="hljs-number">.75</span><span class="hljs-number">.76</span>.<br></code></pre></td></tr></table></figure><p></p><h1 id="函数"><a class="anchor" href="#函数">#</a> <strong>函数</strong></h1><p>函数用法和 C 语言一样</p><p>函数参数限定词说明：</p><table><thead><tr><th>限定词</th><th>说明</th></tr></thead><tbody><tr><td>in</td><td>缺省限定词，可以省略不写</td></tr><tr><td>const</td><td>当前参数为常量，不可在函数内被修改</td></tr><tr><td>out</td><td>① 在函数内使用前必须先初始化 ② 在函数内修改后，对外可见</td></tr><tr><td>inout</td><td>① 接受函数外传入的初始值 ② 在函数内修改后，对外可见</td></tr></tbody></table><p>① 参数限定词只需要用在函数上，函数调用时不用带。</p><p>② 不允许函数递归 这一限制的原因是编译器会把函数都内联展开，以支持没有堆栈的 GPU</p><p></p><figure class="highlight yaml"><figcaption><span>Raw</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">float</span> <span class="hljs-string">square(float</span> <span class="hljs-string">value)</span> <span class="hljs-string">//</span> <span class="hljs-string">求平方</span><br>&#123;<br>    <span class="hljs-string">return</span> <span class="hljs-string">value</span> <span class="hljs-string">*</span> <span class="hljs-string">value;</span><br>&#125;<br><br><span class="hljs-string">void</span> <span class="hljs-string">fuc1(const</span> <span class="hljs-string">float</span> <span class="hljs-string">value)</span> <span class="hljs-string">//</span> <span class="hljs-string">const参数不能在函数内部修改</span><br>&#123;<br>    <span class="hljs-string">//value</span> <span class="hljs-string">=</span> <span class="hljs-number">0.2</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">assignment</span> <span class="hljs-string">to</span> <span class="hljs-string">const</span> <span class="hljs-string">variable</span> <span class="hljs-string">value</span>  <span class="hljs-string">编译错误</span><br>&#125;<br><br><span class="hljs-string">void</span> <span class="hljs-string">fuc2(out</span> <span class="hljs-string">float</span> <span class="hljs-string">value)</span>  <span class="hljs-string">//</span> <span class="hljs-string">value在函数内使用前必须先初始化；在函数内修改，对外可见</span><br>&#123;<br>    <span class="hljs-string">value</span> <span class="hljs-string">=</span> <span class="hljs-number">0.0</span><span class="hljs-string">;</span> <span class="hljs-string">//</span> <span class="hljs-string">注：在函数内使用out参数之前，必须先初始化，否则会编译错误</span><br>    <span class="hljs-string">value</span> <span class="hljs-string">+=</span> <span class="hljs-number">0.5</span><span class="hljs-string">;</span><br>&#125;<br><br><span class="hljs-string">void</span> <span class="hljs-string">fuc3(inout</span> <span class="hljs-string">float</span> <span class="hljs-string">value)</span> <span class="hljs-string">//</span> <span class="hljs-string">value的初始值从函数外传入；在函数内修改，对外可见</span><br>&#123;<br>    <span class="hljs-string">value</span> <span class="hljs-string">+=</span> <span class="hljs-number">0.5</span><span class="hljs-string">;</span><br>&#125;<br><br><span class="hljs-string">int</span> <span class="hljs-string">fun4(int</span> <span class="hljs-string">n)</span>  <span class="hljs-string">//</span> <span class="hljs-string">直接或间接调用fun4函数，会编译报错：recursive</span> <span class="hljs-string">call</span> <span class="hljs-string">to</span> <span class="hljs-string">function</span><br>&#123;<br>    <span class="hljs-string">if</span> <span class="hljs-string">(n</span> <span class="hljs-string">==</span> <span class="hljs-number">0</span> <span class="hljs-string">||</span> <span class="hljs-string">n</span> <span class="hljs-string">==</span> <span class="hljs-number">1</span><span class="hljs-string">)</span><br>    &#123;<br>        <span class="hljs-string">return</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br>    &#125;<br>    <span class="hljs-string">return</span> <span class="hljs-string">fun4(n</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1</span><span class="hljs-string">)</span> <span class="hljs-string">+</span> <span class="hljs-string">fun4(n</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2</span><span class="hljs-string">);</span><br>&#125;<span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><span class="hljs-number">.6</span><span class="hljs-number">.7</span><span class="hljs-number">.8</span><span class="hljs-number">.9</span><span class="hljs-number">.10</span><span class="hljs-number">.11</span><span class="hljs-number">.12</span><span class="hljs-number">.13</span><span class="hljs-number">.14</span><span class="hljs-number">.15</span><span class="hljs-number">.16</span><span class="hljs-number">.17</span><span class="hljs-number">.18</span><span class="hljs-number">.19</span><span class="hljs-number">.20</span><span class="hljs-number">.21</span><span class="hljs-number">.22</span><span class="hljs-number">.23</span><span class="hljs-number">.24</span><span class="hljs-number">.25</span><span class="hljs-number">.26</span><span class="hljs-number">.27</span><span class="hljs-number">.28</span><span class="hljs-number">.29</span><span class="hljs-string">.</span><br></code></pre></td></tr></table></figure><p></p><h2 id="内置函数intrinsic-functions"><a class="anchor" href="#内置函数intrinsic-functions">#</a> <strong>内置函数（Intrinsic Functions）</strong></h2><p>HLSL 提供了一些 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZGhsc2wvZHgtZ3JhcGhpY3MtaGxzbC1pbnRyaW5zaWMtZnVuY3Rpb25z">内置全局函数</span>，它通常直接映射到指定的着色器汇编指令集。这里只列出一些比较常用的函数：</p><table><thead><tr><th>函数</th><th>说明</th><th>最小支持的着色器版本</th></tr></thead><tbody><tr><td>abs(x)</td><td>求 x 的绝对值 注：x 为向量或矩阵时，表示求各分量的 abs</td><td>1.1</td></tr><tr><td>acos(x)</td><td>求 x 的反余弦值</td><td>1.1</td></tr><tr><td>ceil(x)</td><td>返回不小于 x 的最小整数</td><td>1.1</td></tr><tr><td>clamp(x, a, b)</td><td>把 x 夹钳在 [a, b] 内</td><td>1.1</td></tr><tr><td>cos(x)</td><td>计算 x 的余弦值。x 的单位为弧度</td><td>1.1</td></tr><tr><td>cross(u,v)</td><td>计算 u、v 向量的叉乘（外积）</td><td>1.1</td></tr><tr><td>degrees(x)</td><td>将 x 从弧度转成角度</td><td>1.1</td></tr><tr><td>determinant(M)</td><td>返回矩阵的行列式 det (M)</td><td>1.1</td></tr><tr><td>distance(u, v)</td><td colspan="2">返回两点 u 和 v 之间的距离</td><td colspan="2">u - v</td><td></td><td>1.1</td></tr><tr><td>dot(u, v)</td><td>返回向量 u 和 v 的点乘（内积）</td><td>1.1</td></tr><tr><td>dst(u, v)</td><td>计算距离向量</td><td>5.0</td></tr><tr><td>floor(x)</td><td>返回不大于 x 的最大整数</td><td>1.1</td></tr><tr><td>length(v)</td><td colspan="2">返回向量 v 的模</td><td colspan="2">v</td><td></td><td>1.1</td></tr><tr><td>lerp(u, v, t)</td><td>在 u 和 v 之间做线性插值，并返回 t 所在比例的值 注：t 在 [0,1] 之间</td><td>1.1</td></tr><tr><td>log(x)</td><td>返回 ln (x) 注：以 e 为底数的对数值</td><td>1.1</td></tr><tr><td>log10(x)</td><td>返回以 10 为底数的对数值</td><td>1.1</td></tr><tr><td>log2(x)</td><td>返回以 2 为底数的对数值</td><td>1.1</td></tr><tr><td>max(x, y)</td><td>返回 x，y 中的较大的一个</td><td>1.1</td></tr><tr><td>min(x, y)</td><td>返回 x，y 中的较小的一个</td><td>1.1</td></tr><tr><td>mul(M, N)</td><td>矩阵乘法</td></tr><tr><td>若 M 为向量，被视为行向量；若 N 为向量，被视为列向量</td><td>1.1</td></tr><tr><td>normalize(v)</td><td colspan="2">对向量 v 归一化，返回 v /</td><td colspan="2">v</td><td></td><td>1.1</td></tr><tr><td>pow(b, n)</td><td>返回 b 的 n 次幂</td><td>1.1</td></tr><tr><td>radians(x)</td><td>将 x 从角度转为弧度</td><td>1</td></tr><tr><td>reflect(v, n)</td><td>给定入射向量 v 和表面法线 n 时，求出反射向量</td><td>1</td></tr><tr><td>refract(v, n, eta)</td><td>给定折射向量 v、表面法线 n 及两种材质的折射度索引的比率 eta，求出折射向量</td></tr><tr><td>详见：斯涅耳定律（Snell's Law）</td><td>1.1</td></tr><tr><td>rsqrt(x)</td><td>返回 1/sqrt (x)</td><td>1.1</td></tr><tr><td>saturate(x)</td><td>返回 clamp (x, 0.0, 1.0)</td><td>1</td></tr><tr><td>sin(x)</td><td>计算 x 的正弦值。x 的单位为弧度</td><td>1.1</td></tr><tr><td>sincos(in x, out s, out c)</td><td>计算 x 的正弦值 s 和余弦值 c。x 的单位为弧度</td><td>1.1</td></tr><tr><td>sqrt(x)</td><td>对 x 开根号</td><td>1.1</td></tr><tr><td>tan(x)</td><td>返回 x 的正切值。x 的单位为弧度</td><td>1.1</td></tr><tr><td>transpose(M)</td><td>返回矩阵 M 的转置矩阵</td><td>1</td></tr></tbody></table><h1 id="参考"><a class="anchor" href="#参考">#</a> <strong>参考</strong></h1><p>DirectX11--HLSL 语法入门 （csdn）</p><p>DirectX11-- 深入理解 HLSL 常量缓冲区打包规则</p><p>DirectX11-- 深入理解与使用缓冲区资源</p><p>contant buffer 中的 packoffset</p><p>DirectX11 With Windows SDK--03 索引缓冲区、常量缓冲区</p><p>在 DirectX10 中不使用 Effect 框架处理 Shader 与程序间的数据传递</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZDk=">https://docs.microsoft.com/en-us/windows/win32/direct3d9</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZDEw">https://docs.microsoft.com/en-us/windows/win32/direct3d10</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZDEx">https://docs.microsoft.com/en-us/windows/win32/direct3d11</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93aW4zMi9kaXJlY3QzZDEy">https://docs.microsoft.com/en-us/windows/win32/direct3d12</span></p><div class="tags"><a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 图形学笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-12-30 01:22:11" itemprop="dateModified" datetime="2022-12-30T01:22:11+08:00">2022-12-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Natsuneko 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Natsuneko 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Natsuneko 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Natsuneko <i class="ic i-at"><em>@</em></i>夏猫</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="HLSL 语言基础">http://example.com/2022/04/07/图形学笔记/HLSL语言基础/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/MVP%E7%9F%A9%E9%98%B5%20474772934c4146dcb4cddcb94c7b48a4/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;w.wallhaven.cc&#x2F;full&#x2F;o3&#x2F;wallhaven-o3er65.jpg" title="MVP矩阵"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 图形学笔记</span><h3>MVP矩阵</h3></a></div><div class="item right"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HZB%20(Hierarchical%20Z-Buffer)%2084e7171093be454f8b86d1d03ac2310b/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;github.com&#x2F;Natsuneko3&#x2F;wallpaperLibrary&#x2F;raw&#x2F;main&#x2F;wallhaven-0wjq1x.jpg" title="HZB (Hierarchical Z-Buffer)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 图形学笔记</span><h3>HZB (Hierarchical Z-Buffer)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#hlsl%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">HLSL 语言基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">通用着色器的核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text">控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.1.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%94%AF"><span class="toc-number">2.3.2.</span> <span class="toc-text">判断与动态分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.3.3.</span> <span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8register"><span class="toc-number">2.3.4.</span> <span class="toc-text">寄存器（register）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.5.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89"><span class="toc-number">2.3.6.</span> <span class="toc-text">语义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vs%E8%AF%AD%E4%B9%89"><span class="toc-number">2.4.</span> <span class="toc-text">vs 语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ps%E8%AF%AD%E4%B9%89"><span class="toc-number">2.5.</span> <span class="toc-text">ps 语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%80%BC%E8%AF%AD%E4%B9%89"><span class="toc-number">2.6.</span> <span class="toc-text">系统值语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E5%B8%B8%E9%87%8F"><span class="toc-number">2.6.1.</span> <span class="toc-text">着色器常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%BC%93%E5%86%B2%E5%8C%BAconstant-buffer"><span class="toc-number">2.7.</span> <span class="toc-text">常量缓冲区 (Constant Buffer)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%BC%93%E5%86%B2%E5%8C%BAtexture-buffer"><span class="toc-number">2.7.1.</span> <span class="toc-text">纹理缓冲区（Texture Buffer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BAtyped-buffer"><span class="toc-number">2.7.2.</span> <span class="toc-text">有类型的缓冲区 (Typed Buffer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E6%B6%88%E8%80%97%E7%BC%93%E5%86%B2%E5%8C%BAappendconsume-buffer"><span class="toc-number">2.7.3.</span> <span class="toc-text">追加 &#x2F; 消耗缓冲区 (Append&#x2F;Consume Buffer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%9C%B0%E5%9D%80%E7%BC%93%E5%86%B2%E5%8C%BAbyte-address-buffer"><span class="toc-number">2.7.4.</span> <span class="toc-text">字节地址缓冲区 (Byte Address Buffer)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93struct"><span class="toc-number">3.2.</span> <span class="toc-text">结构体（struct）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">向量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">3.4.</span> <span class="toc-text">矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B9%E7%90%86texture"><span class="toc-number">3.5.</span> <span class="toc-text">纹理（texture）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">采样器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.7.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0intrinsic-functions"><span class="toc-number">4.1.</span> <span class="toc-text">内置函数（Intrinsic Functions）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/04/07/GPU/" rel="bookmark" title="GPU">GPU</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" rel="bookmark" title="图形学笔记目录">图形学笔记目录</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Ambient%20Cube%20074e81bf559f43b48fa72e7c2635eae7/" rel="bookmark" title="Ambient Cube">Ambient Cube</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Compute%20shader%20ce8a4f41e18845b0ac4fb1978f28869f/" rel="bookmark" title="Compute shader">Compute shader</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/BRDF%E6%96%B9%E7%A8%8B%2070512469e005449dab1f3eb91452f787/" rel="bookmark" title="BRDF方程">BRDF方程</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/GTAO%20cdb7d5c086e44d4ca1489b7b64c373a0/" rel="bookmark" title="GTAO">GTAO</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HZB%20(Hierarchical%20Z-Buffer)%2084e7171093be454f8b86d1d03ac2310b/" rel="bookmark" title="HZB (Hierarchical Z-Buffer)">HZB (Hierarchical Z-Buffer)</a></li><li class="active"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" rel="bookmark" title="HLSL语言基础">HLSL语言基础</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/MVP%E7%9F%A9%E9%98%B5%20474772934c4146dcb4cddcb94c7b48a4/" rel="bookmark" title="MVP矩阵">MVP矩阵</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/SH%E6%B1%82%E8%B0%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AB%8B%E4%BD%93%E8%A7%92%20ea839e75f76f4b02bfaf515e79810f44/" rel="bookmark" title="SH求谐函数与立体角">SH求谐函数与立体角</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/TAA%20fefed9e1f12f4d78a64918dcba545d9d/" rel="bookmark" title="TAA">TAA</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VXGI%20bac8f80de4544dd7b5e7741bab2ab299/" rel="bookmark" title="VXGI">VXGI</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Visibility%20Buffer%20328fe9588ec5451faf76588581bfd0b1/" rel="bookmark" title="Visibility Buffer">Visibility Buffer</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/" rel="bookmark" title="图片压缩算法">图片压缩算法</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%85%B3%204cf01f6c2d37404ba421f52a0d30f0cc/" rel="bookmark" title="旋转相关">旋转相关</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9%205b7a33b443b4469482b32406094b9773/" rel="bookmark" title="图形学笔记杂项">图形学笔记杂项</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%204c6a1b50e90841d3b3e7ce5734c4210b/" rel="bookmark" title="空间结构划分">空间结构划分</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E8%8C%83%E6%95%B0%207e8460db51a840648bc0541f33b4af00/" rel="bookmark" title="范数">范数</a></li><li><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E8%BF%AD%E4%BB%A3%E6%B3%95%20d5c9fb20c6d746ceadd94b6beb306cd3/" rel="bookmark" title="迭代法">迭代法</a></li><li><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E4%BC%98%E5%8C%96/" rel="bookmark" title="shader优化">shader优化</a></li><li><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E7%BC%96%E8%AF%91/" rel="bookmark" title="shader编译">shader编译</a></li><li><a href="/2022/04/19/Lumen/" rel="bookmark" title="Lumen">Lumen</a></li><li><a href="/2022/04/19/Nanite/" rel="bookmark" title="Nanite">Nanite</a></li><li><a href="/2022/10/19/%E6%B7%B1%E5%85%A5GPU%E5%92%8C%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%20d4b709561b4345e4b120236c4dd265f4/" rel="bookmark" title="深入GPU和渲染优化（基础篇）">深入GPU和渲染优化（基础篇）</a></li><li><a href="/2023/01/09/ShadowMap/" rel="bookmark" title="ShadowMap">ShadowMap</a></li><li><a href="/2023/02/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VirtualTexture/" rel="bookmark" title="VirtualTexture">VirtualTexture</a></li><li><a href="/2023/02/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E8%96%84%E8%86%9C%E5%B9%B2%E6%B6%89/" rel="bookmark" title="薄膜干涉">薄膜干涉</a></li><li><a href="/2023/02/17/%E7%BE%8E%E6%9C%AF%E8%B4%B4%E5%9B%BE%E8%B5%84%E6%BA%90PBR%E6%B5%81%E7%A8%8B/" rel="bookmark" title="美术贴图资源PBR流程">美术贴图资源PBR流程</a></li><li><a href="/2023/09/23/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VolumeRendering/" rel="bookmark" title="Volume Rendering">Volume Rendering</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Natsuneko" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Natsuneko</p><div class="description" itemprop="description">主要分享关于 ue 或者 TA 的知识，也或者分享点自己想写的东西，作品什么的</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">61</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL05hdHN1bmVrbzM=" title="https:&#x2F;&#x2F;github.com&#x2F;Natsuneko3"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9uYXRzdW5la29zYW4=" title="https:&#x2F;&#x2F;twitter.com&#x2F;natsunekosan"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9OYXRzdW5la28=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;Natsuneko"><i class="ic i-zhihu"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVhbHRpbWUueHl6Lw=="><i class="ic i-heart"></i>friends</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/MVP%E7%9F%A9%E9%98%B5%20474772934c4146dcb4cddcb94c7b48a4/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HZB%20(Hierarchical%20Z-Buffer)%2084e7171093be454f8b86d1d03ac2310b/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Natsuneko @ Natsu neko</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">298k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:31</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/04/07/图形学笔记/HLSL语言基础/",favicon:{show:"（●´3｀●）感觉还不错把",hide:"____________________________________"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(_){return _.includes("#")},function(_){return new RegExp(LOCAL.path+"$").test(_)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>