<!DOCTYPE html><html lang="ch"><head><link rel="stylesheet" href="/css/bilicard.css"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="夏猫" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="夏猫" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="夏猫" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记,GPU"><link rel="canonical" href="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/"><meta name="description" content="RHI  全称是 Render Hardware Interface（渲染硬件接口） ，是 UE 渲染体系中非常基础且重要的模块，封装了众多图形 API（DirectX、OpenGL、Vulkan、Metal）之间的差异，对 Game 和 Renderer 模块提供了简便且一致的概念、数据、资源和接口，实现一份渲染代码跑在多个平台的目标。 开启 RHI 线程的情况下，与 RHI 相伴相随的还有 R"><meta property="og:type" content="article"><meta property="og:title" content="RHI 解析"><meta property="og:url" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/index.html"><meta property="og:site_name" content="夏猫"><meta property="og:description" content="RHI  全称是 Render Hardware Interface（渲染硬件接口） ，是 UE 渲染体系中非常基础且重要的模块，封装了众多图形 API（DirectX、OpenGL、Vulkan、Metal）之间的差异，对 Game 和 Renderer 模块提供了简便且一致的概念、数据、资源和接口，实现一份渲染代码跑在多个平台的目标。 开启 RHI 线程的情况下，与 RHI 相伴相随的还有 R"><meta property="og:locale"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%201.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%202.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%203.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%204.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%205.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%206.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%207.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%208.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%209.png"><meta property="og:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled%2010.png"><meta property="article:published_time" content="2023-04-16T04:00:00.000Z"><meta property="article:modified_time" content="2023-06-24T11:43:35.000Z"><meta property="article:author" content="Natsuneko"><meta property="article:tag" content="笔记"><meta property="article:tag" content="GPU"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/Untitled.png"><meta name="twitter:creator" content="@natsunekosan"><title>RHI 解析 - UE 源码笔记 | Natsu neko = 夏猫 = 嵐です！</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">RHI 解析</h1><div class="meta"><span class="item" title="创建时间：2023-04-16 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-04-16T12:00:00+08:00">2023-04-16</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>9 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Natsu neko</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-m9qqek.png"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-839721.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-x89783.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-j3e76y.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-1ke2r9.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-ymz61d.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 UE 源码笔记"><span itemprop="name">UE 源码笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="ch"><link itemprop="mainEntityOfPage" href="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Natsuneko"><meta itemprop="description" content="嵐です！, 主要分享关于 ue 或者 TA 的知识，也或者分享点自己想写的东西，作品什么的"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夏猫"></span><div class="body md" itemprop="articleBody"><p><strong>RHI</strong><br>全称是<strong> Render Hardware Interface（渲染硬件接口）</strong><br>，是 UE 渲染体系中非常基础且重要的模块，封装了众多图形 API（DirectX、OpenGL、Vulkan、Metal）之间的差异，对 Game 和 Renderer 模块提供了简便且一致的概念、数据、资源和接口，实现一份渲染代码跑在多个平台的目标。</p><p>开启 RHI 线程的情况下，与 RHI 相伴相随的还有<strong> RHI 线程</strong><br>，它负责将渲染线程 Push 进来的 RHI 中间指令转译到对应图形平台的 GPU 指令。在部分图形 API（DX12、Vulkan、主机）支持并行的情况下，如果渲染线程是并行生成的 RHI 中间指令，那么 RHI 线程也会并行转译。</p><h1 id="rhi基础"><a class="anchor" href="#rhi基础">#</a> RHI 基础</h1><h2 id="frenderresource"><a class="anchor" href="#frenderresource">#</a> <strong>FRenderResource</strong></h2><p>FRenderResource 是渲染线程的渲染资源代表，由渲染线程管理和传递，介于游戏线程和 RHI 线程的中间数据。FRenderResource 只是基础父类，定义了一组渲染资源的行为，实际的数据和逻辑由子类实现。涉及的子类和层级比较多且复杂。</p><p>他的子类又很多，例如贴图，vertexbuffer，indexbuffer</p><p><img data-src="Untitled.png" alt="Untitled"></p><h2 id="frhiresource"><a class="anchor" href="#frhiresource">#</a> <strong><strong>FRHIResource</strong></strong></h2><p>是 <code>FRenderResource</code> 的父类，FRHIResource 提供了几种功能：引用计数、延迟删除及追踪、运行时数据和标记。RHIResource 的种类和子类都非常多，可分为状态块、着色器绑定、着色器、管线状态、缓冲区、纹理、视图以及其它杂项。需要注意的是，以上只是显示了平台无关的基础类型，实际上，在不同的图形 API 中。例如</p><ul><li>FRHIRenderQueryPool</li><li>FRHIRenderQuery</li><li>FRHITexture</li><li>FRHITexture2D</li><li>FRHITexture2DArray</li><li>FRHITexture3D</li></ul><p>而其他图形 api 都是继承他们各自类</p><p><img data-src="Untitled%201.png" alt="Untitled"></p><h2 id="frhicommand"><a class="anchor" href="#frhicommand">#</a> <strong><strong>FRHICommand</strong></strong></h2><p>FRHICommand 是 RHI 模块的渲染指令基类，这些指令通常由渲染线程通过命令队列 Push 到 RHI 线程，在合适的时机由 RHI 线程执行。FRHICommand 同时又继承自 FRHICommandBase</p><p>RHI 命令种类繁多，主要包含以下几大类：</p><ul><li>数据和资源的设置、更新、清理、转换、拷贝、回读。</li><li>图元绘制。</li><li>Pass、SubPass、场景、ViewPort 等的开始和结束事件。</li><li>栅栏、等待、广播接口。</li><li>光线追踪。</li><li>Slate、调试相关的命令。</li></ul><h2 id="frhicommandlist"><a class="anchor" href="#frhicommandlist">#</a> <strong><strong>FRHICommandList</strong></strong></h2><p>FRHICommandList 是 RHI 的指令队列，用来管理、执行一组 FRHICommand 的对象。</p><ul><li><code>FRHICommandListBase</code> 定义了命令队列所需的基本数据（命令列表、设备上下文）和接口（命令的刷新、等待、入队、派发等，内存分配）。</li><li><code>FRHIComputeCommandList</code> 定义了计算着色器相关的接口、GPU 资源状态转换和着色器部分参数的设置。</li><li><code>FRHICommandList</code> 定义了普通渲染管线的接口，包含 VS、PS、GS 的绑定，图元绘制，更多着色器参数的设置和资源状态转换，资源创建、更新和等待等等。</li></ul><p>FRHICommandList 还有数个子类，就是 FRHICommandListImmediate，他封装了立即模式的图形 API 接口，在 UE 渲染体系中被应用得非常广泛。它额外定义了资源的操作、创建、更新、读取和状态转换接口，也增加了线程同步和 GPU 同步的接口。</p><p><img data-src="Untitled%202.png" alt="Untitled"></p><p><img data-src="Untitled%203.png" alt="Untitled"></p><h1 id="rhicontext-dynamicrhi"><a class="anchor" href="#rhicontext-dynamicrhi">#</a> <strong><strong>RHIContext, DynamicRHI</strong></strong></h1><h2 id="irhicommandcontext"><a class="anchor" href="#irhicommandcontext">#</a> <strong><strong>IRHICommandContext</strong></strong></h2><p>IRHICommandContext 是 RHI 的命令上下文接口类，定义了一组图形 API 相关的操作。在可以并行处理命令列表的平台上，它是一个单独的对象。</p><p>IRHICommandContext 的接口和 FRHICommandList 的接口高度相似且重叠。IRHICommandContext 还有许多子类：</p><ul><li>IRHICommandContextPSOFallback：不支持真正的图形管道的 RHI 命令上下文。<ul><li>FNullDynamicRHI：空实现的动态绑定 RHI。</li><li>FOpenGLDynamicRHI：OpenGL 的动态 RHI。</li><li>FD3D11DynamicRHI：D3D11 的动态 RHI。</li></ul></li><li>FMetalRHICommandContext：Metal 平台的命令上下文。</li><li>FD3D12CommandContextBase：D3D12 的命令上下文。</li><li>FVulkanCommandListContext：Vulkan 平台的命令队列上下文。</li><li>FEmptyDynamicRHI：动态绑定的 RHI 实现的接口。</li><li>FValidationContext：校验上下文。</li></ul><p>上述的子类中，平台相关的部分子类还继承了 FDynamicRHI。IRHICommandContextPSOFallback 比较特殊，它的子类都是不支持并行绘制的图形 API（OpenGL、D3D11）。</p><h2 id="irhicommandcontextcontainerue5已弃用"><a class="anchor" href="#irhicommandcontextcontainerue5已弃用">#</a> <strong><strong>IRHICommandContextContainer (ue5 已弃用)</strong></strong></h2><p>IRHICommandContextContainer 就是包含了 IRHICommandContext 对象的类型，存储了一个或一组命令上下文的容器，以支持并行化地提交命令队列，只在 D3D12、Metal、Vulkan 等现代图形 API 中有实现。</p><p><img data-src="Untitled%204.png" alt="Untitled"></p><h2 id="fdynamicrhi"><a class="anchor" href="#fdynamicrhi">#</a> <strong><strong>FDynamicRHI</strong></strong></h2><p>FDynamicRHI 是由动态绑定的 RHI 实现的接口，它定义的接口和 CommandList、CommandContext 比较相似，</p><p><img data-src="Untitled%205.png" alt="Untitled"></p><p>需要注意的是，传统图形 API（D3D11、OpenGL）除了继承 FDynamicRHI，还需要继承 IRHICommandContextPSOFallback，因为需要借助后者的接口处理 PSO 的数据和行为，以保证传统和现代 API 对 PSO 的一致处理行为。也正因为此，现代图形 API（D3D12、Vulkan、Metal）不需要继承 IRHICommandContext 的任何继承体系的类型，单单直接继承 FDynamicRHI 就可以处理 RHI 层的所有数据和操作。</p><p>既然现代图形 API（D3D12、Vulkan、Metal）的 DynamicRHI 没有继承 IRHICommandContext 的任何继承体系的类型</p><h3 id="fd3d12dynamicrhi"><a class="anchor" href="#fd3d12dynamicrhi">#</a> <strong><strong>FD3D12DynamicRHI</strong></strong></h3><p><img data-src="Untitled%206.png" alt="Untitled"></p><h2 id="rhi体系总览"><a class="anchor" href="#rhi体系总览">#</a> <strong><strong>RHI 体系总览</strong></strong></h2><p><img data-src="Untitled%207.png" alt="Untitled"></p><h1 id="rhi机制"><a class="anchor" href="#rhi机制">#</a> RHI 机制</h1><h2 id="rhi命令执行"><a class="anchor" href="#rhi命令执行">#</a> <strong><strong>RHI 命令执行</strong></strong></h2><h3 id="frhicommandlistexecutor"><a class="anchor" href="#frhicommandlistexecutor">#</a> <strong><strong>FRHICommandListExecutor</strong></strong></h3><p>FRHICommandListExecutor 负责将 Renderer 层的 RHI 中间指令转译（或直接调用）到目标平台的图形 API，它在 RHI 体系中起着举足轻重的作用，在派发和转译命令队列时，可能在专用的 RHI 线程执行，也可能在渲染线程或工作线程执行。</p><h3 id="grhicommandlist"><a class="anchor" href="#grhicommandlist">#</a> <strong><strong>GRHICommandList</strong></strong></h3><p>是 FRHICommandListExecutor 的实例。</p><p>总结一下这些任务变量的作用：</p><table><thead><tr><th>任务变量</th><th>执行线程</th><th>描述</th></tr></thead><tbody><tr><td>AllOutstandingTasks</td><td>渲染、RHI、工作</td><td>所有在处理或待处理的任务列表。类型是 FParallelTranslateSetupCommandList、FParallelTranslateCommandList。</td></tr><tr><td>WaitOutstandingTasks</td><td>渲染、RHI、工作</td><td>待处理的任务列表。类型是 FParallelTranslateSetupCommandList、FParallelTranslateCommandList。</td></tr><tr><td>RHIThreadTask</td><td>RHI、工作</td><td>正在处理的 RHI 线程任务。类型是 FExecuteRHIThreadTask。</td></tr><tr><td>PrevRHIThreadTask</td><td>RHI、工作</td><td>上一次处理的 RHIThreadTask。类型是 FExecuteRHIThreadTask。</td></tr><tr><td>RenderThreadSublistDispatchTask</td><td>渲染、RHI、工作</td><td>正在派发（提交）的任务。类型是 FDispatchRHIThreadTask。</td></tr></tbody></table><h3 id="d3d11命令执行"><a class="anchor" href="#d3d11命令执行">#</a> <strong><strong>D3D11 命令执行</strong></strong></h3><p>在 PC 的默认图形 API（D3D11）下，r.RHICmdBypass1 且 r.RHIThread.Enable0，FRHICommandList 将直接调用图形 API 的上下文的接口，相当于同步调用图形 API，此时的图形 API 运行于渲染线程（如果开启）。</p><p>接着将 r.RHICmdBypass 设为 0，但保持 r.RHIThread.Enable 为 0，此时不再直接调用 Context 的方法，而是通过生成一条条单独的 FRHICommand，然后由 FRHICommandList 相关的对象执行。</p><p>以 FRHICommandList::DrawPrimitive 为例，调用流程示意图如下</p><p>↓ FRHICommandListImmediate::ImmediateFlush<br>↓ FRHICommandListExecutor::ExecuteList<br>↓ FRHICommandListExecutor::ExecuteInner<br>↓ FRHICommandListExecutor::ExecuteInner_DoExecute<br>↓ FRHICommand::ExecuteAndDestruct<br>↓ FRHICommandDrawPrimitive::Execute<br>↓ INTERNAL_DECORATOR<br>↓ FD3D11DynamicRHI::RHIDrawPrimitive</p><h2 id="immediateflush"><a class="anchor" href="#immediateflush">#</a> <strong><strong>ImmediateFlush</strong></strong></h2><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Engine\Source\Runtime\RHI\Public\RHICommandList.h</span><br><br><span class="hljs-keyword">namespace</span> EImmediateFlushType<br>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span><br>    &#123; <br>        WaitForOutstandingTasksOnly = <span class="hljs-number">0</span>, <span class="hljs-comment">// 等待仅正在处理的任务完成.</span><br>        DispatchToRHIThread,             <span class="hljs-comment">// 派发到RHI线程.</span><br>        WaitForDispatchToRHIThread,      <span class="hljs-comment">// 等待派发到RHI线程.</span><br>        FlushRHIThread,                  <span class="hljs-comment">// 刷新RHI线程.</span><br>        FlushRHIThreadFlushResources,    <span class="hljs-comment">// 刷新RHI线程和资源</span><br>        FlushRHIThreadFlushResourcesFlushDeferredDeletes <span class="hljs-comment">// 刷新RHI线程/资源和延迟删除.</span><br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p></p><h2 id="并行渲染"><a class="anchor" href="#并行渲染">#</a> <strong><strong>并行渲染</strong></strong></h2><p>本篇开头也提到了在开启 RHI 线程的情况下，RHI 线程负责将渲染线程 Push 进来的 RHI 中间指令转译到对应图形平台的 GPU 指令。如果渲染线程是并行生成的 RHI 中间指令，那么 RHI 线程也会并行转译。</p><p><img data-src="Untitled%208.png" alt="Untitled"></p><h3 id="fparallelcommandlistset"><a class="anchor" href="#fparallelcommandlistset">#</a> <strong><strong>FParallelCommandListSet</strong></strong></h3><p>FParallelCommandListSet 拥有以下子类，以满足不同 Pass 或场合的并行渲染逻辑：</p><ul><li>FShadowParallelCommandListSet：阴影渲染的并行渲染命令队列集合。</li><li>FRDGParallelCommandListSet：RDG 系统的并行渲染命令队列集合。</li></ul><p>FParallelMeshDrawCommandPass::DispatchDraw 调用之后，创建若干个 FRHICommandList、FDrawVisibleMeshCommandsAnyThreadTask 任务和任务同步事件，然后将它们全部加入到 ParallelCommandListSet 的列表中。这样，当 ParallelCommandListSet 被析构时，就可以真正地派发命令队列。</p><h3 id="queueparallelasynccommandlistsubmit"><a class="anchor" href="#queueparallelasynccommandlistsubmit">#</a> <strong><strong>QueueParallelAsyncCommandListSubmit</strong></strong></h3><p>调用 FParallelCommandListSet::Dispatch 之后，会进入 FRHICommandListBase::QueueParallelAsyncCommandListSubmit</p><p>开启并行命令队列提交需要满足以下条件：</p><ul><li>开启了 RHI 线程，即 IsRunningRHIInSeparateThread () 为 true。</li><li>当前使用的图形 API 支持并行执行，即 GRHISupportsParallelRHIExecute 要为 true。</li><li>开启了延迟上下文，即 CVarRHICmdUseDeferredContexts 不为 0。</li></ul><p>无论是哪个图形 API，都需要指定一个主 CommandList（即 ParentCommandList），以便调用它的 QueueParallelAsyncCommandListSubmit 提交设置命令队列的任务。上面提交到 RHI 线程的任务对象是 FParallelTranslateSetupCommandList，</p><h3 id="fparalleltranslatesetupcommandlist"><a class="anchor" href="#fparalleltranslatesetupcommandlist">#</a> <strong><strong>FParallelTranslateSetupCommandList</strong></strong></h3><p>FParallelTranslateSetupCommandList 用于建立并行（或串行）提交子命令队列的任务</p><ul><li><p>如果命令数量太少，所需的线程数量过少，直接使用串行转译接口 FRHICommandWaitForAndSubmitSubList。</p></li><li><p>并行逻辑分支中，RHIGetCommandContextContainer 从具体的 RHI 子类中获取上下文容器，只在 D3D12、Vulkan、Metal 等现代图形平台中有实现，其它图形平台皆返回 nullptr。</p></li><li><p>每个线程会提交 1~N 个子命令队列，以确保它们的绘制命令总数不少于 MinSize，提升每个线程的提交效率。</p></li><li><p>每个线程会创建一个转译任务 FParallelTranslateCommandList，然后利用 RHICmdList 的 FRHICommandWaitForAndSubmitSubListParallel 取等待子命令列表的并行提交。</p></li><li><p>注意 FParallelTranslateSetupCommandList 的预期线程由 CPrio_FParallelTranslateSetupCommandList 决定：</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">FAutoConsoleTaskPriority CPrio_FParallelTranslateSetupCommandList<br>    // 控制台名称.<br>    TEXT(&quot;TaskGraph.TaskPriorities.ParallelTranslateSetupCommandList&quot;),<br>    // 描述.<br>    TEXT(&quot;Task and thread priority for FParallelTranslateSetupCommandList.&quot;),<br>    // 如果有高优先级的线程, 使用之.<br>    ENamedThreads::HighThreadPriority,<br>    // 使用高任务优先级.<br>    ENamedThreads::HighTaskPriority,<br>    // 如果没有高优先级的线程, 则使用普遍优先级的线程, 但使用高任务优先级代替之.<br>    ENamedThreads::HighTaskPriority<br>    );<br><br></code></pre></td></tr></table></figure><p></p><p>因此可知，设置转译的任务会被 TaskGraph 系统优先执行，但发起设置转译任务的线程还是渲染线程而非 RHI 线程。</p></li></ul><h3 id="fparalleltranslatecommandlist"><a class="anchor" href="#fparalleltranslatecommandlist">#</a> <strong><strong>FParallelTranslateCommandList</strong></strong></h3><p>FParallelTranslateCommandList 便是真正地转译命令队列，如果是 prepass，使用普通优先级的线程但高任务优先级，其它 pass 则使用普通优先级的线程和普通的任务优先级。</p><h2 id="pass渲染"><a class="anchor" href="#pass渲染">#</a> <strong><strong>Pass 渲染</strong></strong></h2><h3 id="subpass渲染"><a class="anchor" href="#subpass渲染">#</a> <strong><strong>Subpass 渲染</strong></strong></h3><p>先说一下 Subpass 的由来、作用和特点。</p><p>在传统的多 Pass 渲染中，每个 Pass 结束时通常会渲染出一组渲染纹理，部分成为着色器参数提供给下一个 Pass 采样读取。这种纹理采样方式不受任何限制，可以读取任意的领域像素，使用任意的纹理过滤方式。这种方式虽然使用灵活，但在 TBR（Tile-Based Renderer）硬件架构的设备中会有较大的消耗：渲染纹理的 Pass 通常会将渲染结果存储在 On-chip 的 Tile Memory 中，待 Pass 结束后会写回 GPU 显存（VRAM）中，写回 GPU 显存是个耗时耗耗电的操作。</p><p><em>传统多 Pass 之间的内存存取模型，多次发生于 On-Chip 和全局存储器之间。</em></p><p>如果出现一种特殊的纹理使用情况：上一个 Pass 渲染处理的纹理，立即被下一个 Pass 使用，并且下一个 Pass 只采样像素位置自身的数据，而不需要采样邻域像素的位置。这种情况就符合了 Subpass 的使用情景。使用 Subpass 渲染的纹理结果只会存储在 Tile Memory 中，在 Subpass 结束后不会写回 VRAM，而直接提供 Tile Memory 的数据给下一个 Subpass 采样读取。这样就避免了传统 Pass 结束写回 GPU 显存以及下一个 Pass 又从 GPU 显存读数据的耗时耗电操作，从而提升了性能。</p><p><em>Subpass 之间的内存存取模型，都发生在 On-Chip 内。</em></p><p>Subpass 主要集中在移动端渲染器，原因是移动端 TBR 架构的硬件设备越来越多，占比愈来愈大，Subpass 成为移动端主渲染器的首选是必然且合理的。在 Subpass 渲染中，还是涉及到了 Pass 的 Overlap 问题，采用 Overlap 可以提升 GPU 的使用率，提升渲染性能（下图）</p><p><img data-src="Untitled%209.png" alt="Untitled"></p><h2 id="rhi资源管理"><a class="anchor" href="#rhi资源管理">#</a> <strong><strong>RHI 资源管理</strong></strong></h2><p>FRHIResource 自身拥有引用计数和引用计数增加、减少的接口：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RHI_API</span> FRHIResource<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 增加引用计数.</span><br>    <span class="hljs-function">uint32 <span class="hljs-title">AddRef</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 减少引用计数.</span><br>    <span class="hljs-function">uint32 <span class="hljs-title">Release</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 获取引用计数.</span><br>    <span class="hljs-function">uint32 <span class="hljs-title">GetRefCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p></p><p>我们不需要直接引用和管理 FRHIResource 的实例和计数，而是结合 TRefCountPtr 的模板类实现自动化管理 RHI 资源，需要特意指出，FRHIResource 的析构函数并没有释放任何 RHI 资源，通常需要在 FRHIResource 的图形平台相关的子类析构函数中执行，RHI 资源的释放主要在 FlushPendingDeletes 接口中，</p><p>RHI 抽象层主要是以上几处调用 FlushPendingDeletes，但以下的图形平台相关的接口也会调用：</p><ul><li>FD3D12Adapter::Cleanup()</li><li>FD3D12Device::Cleanup()</li><li>FVulkanDevice::Destroy()</li><li>FVulkanDynamicRHI::Shutdown()</li><li>FD3D11DynamicRHI::CleanupD3DDevice()</li></ul><h2 id="多线程渲染"><a class="anchor" href="#多线程渲染">#</a> <strong><strong>多线程渲染</strong></strong></h2><p><img data-src="Untitled%2010.png" alt="Untitled"></p><p>UE 的渲染流程中，最多存在 4 种工作线程：游戏线程（Game Thread）、渲染线程（Render Thread）、RHI 线程和 GPU（含驱动）。</p><p>游戏线程是整个引擎的驱动者，提供所有的源数据和事件，以驱动渲染线程和 RHI 线程。游戏线程领先渲染线程不超过 1 帧，更具体地说如果第 N 帧的渲染线程在第 N+1 帧的游戏线程的 Tick 结束时还没有完成，那么游戏线程会被渲染线程卡住。反之，如果游戏线程负载过重，没能及时发送事件和数据给渲染线程，也会导致渲染线程卡住。</p><p>渲染线程负责产生 RHI 的中间命令，在适当的时机派发、刷新指令到 RHI 线程。因此，渲染线程的卡顿也可能导致 RHI 的卡顿。</p><p>RHI 线程负责派发（可选）、转译、提交指令，且渲染的最后一步需要 SwapBuffer，这一步需要等待 GPU 完成渲染工作。因此，渲染 GPU 的繁忙也会导致 RHI 线程的卡顿。</p><p>除了游戏线程，渲染线程、RHI 线程和 GPU 的工作都是存在间隙的，即游戏线程提供给渲染任务的时机会影响渲染工作的密度，也会影响到渲染的时间，小量多次会浪费渲染效率。</p><h2 id="rhi控制台变量"><a class="anchor" href="#rhi控制台变量">#</a> <strong><strong>RHI 控制台变量</strong></strong></h2><p>前面章节的代码也显示 RHI 体系涉及的控制台变量非常多，下面列出部分控制台变量，以便调试、优化 RHI 渲染效果或效率：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cDovL3IuUkhJLk5hbWU=">r.RHI.Name</span></td><td>显示当前 RHI 的名字，如 D3D11。</td></tr><tr><td>r.RHICmdAsyncRHIThreadDispatch</td><td>实验选项，是否执行 RHI 调度异步。可使数据更快地刷新到 RHI 线程，避免帧末尾出现卡顿。</td></tr><tr><td>r.RHICmdBalanceParallelLists</td><td>允许启用 DrawList 的预处理，以尝试在命令列表之间均衡负载。0：关闭，1：开启，2：实验选项，使用上一帧的结果（在分屏等不做任何事情）。</td></tr><tr><td>r.RHICmdBalanceTranslatesAfterTasks</td><td>实验选项，平衡并行翻译后的渲染任务完成。可最小化延迟上下文的数量，但会增加启动转译的延迟。</td></tr><tr><td>r.RHICmdBufferWriteLocks</td><td>仅与 RHI 线程相关。用于诊断缓冲锁问题的调试选项。</td></tr><tr><td>r.RHICmdBypass</td><td>是否绕过 RHI 命令列表，立即发送 RHI 命令。0：禁用（需开启多线程渲染），1：开启。</td></tr><tr><td>r.RHICmdCollectRHIThreadStatsFromHighLevel</td><td>这将在执行的 RHI 线程上推送统计信息，这样就可以确定它们来自哪个高层级的 Pass。对帧速率有不利影响。默认开启。</td></tr><tr><td>r.RHICmdFlushOnQueueParallelSubmit</td><td>在提交后立即等待并行命令列表的完成。问题诊断。只适用于部分 RHI。</td></tr><tr><td>r.RHICmdFlushRenderThreadTasks</td><td>如果为真，则每次调用时都刷新渲染线程任务。问题诊断。这是一个更细粒度 cvars 的主开关。</td></tr><tr><td>r.RHICmdForceRHIFlush</td><td>对每个任务强制刷新发送给 RHI 线程。问题诊断。</td></tr><tr><td>r.RHICmdMergeSmallDeferredContexts</td><td>合并小的并行转译任务，基于 r.RHICmdMinDrawsPerParallelCmdList。</td></tr><tr><td>r.RHICmdUseDeferredContexts</td><td>使用延迟上下文并行执行命令列表。只适用于部分 RHI。</td></tr><tr><td>r.RHICmdUseParallelAlgorithms</td><td>True 使用并行算法。如果 r.RHICmdBypass 为 1 则忽略。</td></tr><tr><td>r.RHICmdUseThread</td><td>使用 RHI 线程。问题诊断。</td></tr><tr><td>r.RHICmdWidth</td><td>控制并行渲染器中大量事物的任务粒度。</td></tr><tr><td>r.RHIThread.Enable</td><td>启用 / 禁用 RHI 线程，并确定 RHI 工作是否在专用线程上运行。</td></tr><tr><td>RHI.GPUHitchThreshold</td><td>GPU 上检测卡顿的阈值 (毫秒)。</td></tr><tr><td>RHI.MaximumFrameLatency</td><td>可以排队进行渲染的帧数。</td></tr><tr><td>RHI.SyncThreshold</td><td>在垂直同步功能启用前的连续 “快速” 帧数。</td></tr><tr><td>RHI.TargetRefreshRate</td><td>如果非零，则显示的更新频率永远不会超过目标刷新率 (以 Hz 为单位)。</td></tr></tbody></table><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a> <a href="/tags/GPU/" rel="tag"><i class="ic i-tag"></i> GPU</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-06-24 19:43:35" itemprop="dateModified" datetime="2023-06-24T19:43:35+08:00">2023-06-24</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Natsuneko 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Natsuneko 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Natsuneko 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Natsuneko <i class="ic i-at"><em>@</em></i>夏猫</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/" title="RHI 解析">http://example.com/2023/04/16/ue源码/RHI解析/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/04/01/CPPBasicKnowledge/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;github.com&#x2F;Natsuneko3&#x2F;wallpaperLibrary&#x2F;raw&#x2F;main&#x2F;wallhaven-m9qqek.png" title="C++基础知识"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++ 笔记</span><h3>C++基础知识</h3></a></div><div class="item right"><a href="/2023/05/31/ue%E6%BA%90%E7%A0%81/%E6%96%B0%E5%BB%BAniagara%20renderer/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;github.com&#x2F;Natsuneko3&#x2F;wallpaperLibrary&#x2F;raw&#x2F;main&#x2F;wallhaven-57vkd7.png" title="新建niagara renderer"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> UE 源码笔记</span><h3>新建niagara renderer</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rhi%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">RHI 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#frenderresource"><span class="toc-number">1.1.</span> <span class="toc-text">FRenderResource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frhiresource"><span class="toc-number">1.2.</span> <span class="toc-text">FRHIResource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frhicommand"><span class="toc-number">1.3.</span> <span class="toc-text">FRHICommand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frhicommandlist"><span class="toc-number">1.4.</span> <span class="toc-text">FRHICommandList</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rhicontext-dynamicrhi"><span class="toc-number">2.</span> <span class="toc-text">RHIContext, DynamicRHI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#irhicommandcontext"><span class="toc-number">2.1.</span> <span class="toc-text">IRHICommandContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#irhicommandcontextcontainerue5%E5%B7%B2%E5%BC%83%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">IRHICommandContextContainer (ue5 已弃用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fdynamicrhi"><span class="toc-number">2.3.</span> <span class="toc-text">FDynamicRHI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fd3d12dynamicrhi"><span class="toc-number">2.3.1.</span> <span class="toc-text">FD3D12DynamicRHI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rhi%E4%BD%93%E7%B3%BB%E6%80%BB%E8%A7%88"><span class="toc-number">2.4.</span> <span class="toc-text">RHI 体系总览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rhi%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">RHI 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rhi%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">RHI 命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#frhicommandlistexecutor"><span class="toc-number">3.1.1.</span> <span class="toc-text">FRHICommandListExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grhicommandlist"><span class="toc-number">3.1.2.</span> <span class="toc-text">GRHICommandList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d3d11%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.3.</span> <span class="toc-text">D3D11 命令执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#immediateflush"><span class="toc-number">3.2.</span> <span class="toc-text">ImmediateFlush</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%B8%B2%E6%9F%93"><span class="toc-number">3.3.</span> <span class="toc-text">并行渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fparallelcommandlistset"><span class="toc-number">3.3.1.</span> <span class="toc-text">FParallelCommandListSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queueparallelasynccommandlistsubmit"><span class="toc-number">3.3.2.</span> <span class="toc-text">QueueParallelAsyncCommandListSubmit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fparalleltranslatesetupcommandlist"><span class="toc-number">3.3.3.</span> <span class="toc-text">FParallelTranslateSetupCommandList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fparalleltranslatecommandlist"><span class="toc-number">3.3.4.</span> <span class="toc-text">FParallelTranslateCommandList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pass%E6%B8%B2%E6%9F%93"><span class="toc-number">3.4.</span> <span class="toc-text">Pass 渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#subpass%E6%B8%B2%E6%9F%93"><span class="toc-number">3.4.1.</span> <span class="toc-text">Subpass 渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rhi%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">RHI 资源管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93"><span class="toc-number">3.6.</span> <span class="toc-text">多线程渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rhi%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8F%98%E9%87%8F"><span class="toc-number">3.7.</span> <span class="toc-text">RHI 控制台变量</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/04/07/ue%E6%BA%90%E7%A0%81/%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/" rel="bookmark" title="材质系统解析">材质系统解析</a></li><li><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/UnifomBuffer/" rel="bookmark" title="UnifomBuffer">UnifomBuffer</a></li><li><a href="/2022/05/18/ue%E6%BA%90%E7%A0%81/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="bookmark" title="智能指针">智能指针</a></li><li><a href="/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" rel="bookmark" title="渲染机制解析">渲染机制解析</a></li><li><a href="/2023/01/02/NiagaraDataInterface/" rel="bookmark" title="使用自定义Niagara数据接口">使用自定义Niagara数据接口</a></li><li><a href="/2023/01/30/ue%E6%BA%90%E7%A0%81/UEShadowMapRendering/" rel="bookmark" title="阴影渲染机制">阴影渲染机制</a></li><li><a href="/2023/02/03/ue%E6%BA%90%E7%A0%81/Virtual%20Texture%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Virtual Texture解析">Virtual Texture解析</a></li><li class="active"><a href="/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/" rel="bookmark" title="RHI解析">RHI解析</a></li><li><a href="/2023/05/31/ue%E6%BA%90%E7%A0%81/%E6%96%B0%E5%BB%BAniagara%20renderer/" rel="bookmark" title="新建niagara renderer">新建niagara renderer</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Natsuneko" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Natsuneko</p><div class="description" itemprop="description">主要分享关于 ue 或者 TA 的知识，也或者分享点自己想写的东西，作品什么的</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">61</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL05hdHN1bmVrbzM=" title="https:&#x2F;&#x2F;github.com&#x2F;Natsuneko3"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9uYXRzdW5la29zYW4=" title="https:&#x2F;&#x2F;twitter.com&#x2F;natsunekosan"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9OYXRzdW5la28=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;Natsuneko"><i class="ic i-zhihu"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVhbHRpbWUueHl6Lw=="><i class="ic i-heart"></i>friends</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/04/01/CPPBasicKnowledge/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/31/ue%E6%BA%90%E7%A0%81/%E6%96%B0%E5%BB%BAniagara%20renderer/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Natsuneko @ Natsu neko</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">298k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:31</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/04/16/ue源码/RHI解析/",favicon:{show:"（●´3｀●）感觉还不错把",hide:"____________________________________"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(_){return _.includes("#")},function(_){return new RegExp(LOCAL.path+"$").test(_)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>