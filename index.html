<!DOCTYPE html><html lang="ch"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="夏猫" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="夏猫" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="夏猫" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="关键词1,关键词2"><link rel="canonical" href="http://example.com/"><meta name="description" content="主要分享关于ue或者TA的知识，也或者分享点自己想写的东西，作品什么的"><meta property="og:type" content="website"><meta property="og:title" content="夏猫"><meta property="og:url" content="http://example.com/index.html"><meta property="og:site_name" content="夏猫"><meta property="og:description" content="主要分享关于ue或者TA的知识，也或者分享点自己想写的东西，作品什么的"><meta property="og:locale"><meta property="article:author" content="Natsuneko"><meta name="twitter:card" content="summary"><meta name="twitter:creator" content="@natsunekosan"><title>Natsu neko = 夏猫 = 嵐です！</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><a href="/" class="logo" rel="start"><p class="artboard">Natsu neko</p><h1 itemprop="name headline" class="title">夏猫</h1></a><p class="meta" itemprop="description">= 嵐です！ =</p></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Natsu neko</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-95zmlk.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-yx73xg.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-ox9kyl.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-ymz61d.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-dpw3wg.jpg"></li><li class="item" data-background-image="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-gp8y37.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="index wrap"><h2 class="divider">置顶文章</h2><div class="segments sticky"><article class="item"><div class="cover"><a href="/2022/12/17/WallpaperEnging/" itemprop="url" title="把ue变成WallpaperEngine"><img data-src="https://w.wallhaven.cc/full/e7/wallhaven-e72x6k.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-12-17 18:34:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-12-17T18:34:00+08:00">2022-12-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>572</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/12/17/WallpaperEnging/" itemprop="url" title="把ue变成WallpaperEngine">把ue变成WallpaperEngine</a></h3><div class="excerpt"># WallpaperEnginePlugin 这是一个可以改变你 ue 界面的小插件，慢慢更新 下载地址： UE4.26 UE4.27 UE5.0 UE5.1 # 使用方法 1. 选择你引擎对应版本，把 plugins 解压到你项目根目录下。 # 例如: 解压到 Plugins 文件夹下，要是没有自己新建个即可 然后重新编译 要是打开引擎要是提醒版本不同，点是就行 把静态图片放在这文件夹下面，上面列表会自动同步列表，要是视频的话，会自动同步 WallpaperEngine。 # 设置界面说明 💙 Use Wallpaper Engine : 播放视频，ue5.0 版本中...</div><div class="meta footer"><span><a href="/categories/%E6%8F%92%E4%BB%B6/" itemprop="url" title="插件"><i class="ic i-flag"></i>插件</a></span></div><a href="/2022/12/17/WallpaperEnging/" itemprop="url" title="把ue变成WallpaperEngine" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记目录"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-1kl36v.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>490</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记目录">图形学笔记目录</a></h3><div class="excerpt"># 图形学笔记 图形学笔记 # Lumen # Nanite # 迭代法 # 范数 # Compute shader # BRDF 方程 # Ambient Cube # HZB (Hierarchical Z-Buffer) # MVP 矩阵 # SH 求谐函数与立体角 # TAA # 图片压缩算法 # 空间结构划分 # Visibility Buffer # Visibility Buffer # GTAO # 四元数 # 杂项 # HLSL 语言基础 # ShadowMap # Virtual Texture # 薄膜干涉 # Volume...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记目录" class="btn">more...</a></div></article></div><h2 class="divider">文章列表</h2><div class="segments posts"><article class="item"><div class="cover"><a href="/2023/10/16/simulation/%E7%9F%A9%E9%98%B5/SingularValueDecomposition/" itemprop="url" title="奇异值分解"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-dp9mlj.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-10-16 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-10-16T12:00:00+08:00">2023-10-16</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>10 分钟</span></span></div><h3><a href="/2023/10/16/simulation/%E7%9F%A9%E9%98%B5/SingularValueDecomposition/" itemprop="url" title="奇异值分解">奇异值分解</a></h3><div class="excerpt"># 奇异值分解 # 特征值和特征向量 特征值和特征向量的定义如下 𝐴𝑥=𝜆𝑥 其中 A 是一个𝑛×𝑛的实对称矩阵，𝑥是一个𝑛维向量，则我们说𝜆是矩阵 A 的一个特征值，而𝑥是矩阵 A 的特征值𝜆所对应的特征向量。 # SVD 定义 D 也是对矩阵进行分解，但是和特征分解不同，SVD 并不要求要分解的矩阵为方阵。假设我们的矩阵 A 是一个𝑚×𝑛的矩阵，那么我们定义矩阵 A 的 SVD 为： A=UΣVTA = U&#92;Sigma V^T A=UΣVT 其中 U 是一个𝑚×𝑚的矩阵，Σ 是一个𝑚×𝑛的矩阵，除了主对角线上的元素以外全为...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2023/10/16/simulation/%E7%9F%A9%E9%98%B5/SingularValueDecomposition/" itemprop="url" title="奇异值分解" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/09/23/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VolumeRendering/" itemprop="url" title="Volume Rendering"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-xlxdm3.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-09-23 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-09-23T12:00:00+08:00">2023-09-23</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2023/09/23/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VolumeRendering/" itemprop="url" title="Volume Rendering">Volume Rendering</a></h3><div class="excerpt"># Volume Rendering 在光传播时，抽象点来说就是分子把收集到的光带到你的眼睛里，但这过程中会发生各种情况扰乱光的传播。 通过介质传播到眼睛的光束会由于以下原因损失能量 吸收（Absorption）吸收了一部份的光，把收集到的光吸收了一部份 外散射（Out-scattering）把一部份光散射出去给别的分子，从而光能力不能到你的眼睛 通过介质传播到眼睛的光束会由于以下原因损失能量 自发光（Emissive）就是自己的光能量 内散射（In- Scattering）把从四面八方发射出来的光收集起来带到我们的眼睛，可以理解为 Irradiance 渲染时候用...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2023/09/23/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VolumeRendering/" itemprop="url" title="Volume Rendering" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/05/31/ue%E6%BA%90%E7%A0%81/%E6%96%B0%E5%BB%BAniagara%20renderer/" itemprop="url" title="新建niagara renderer"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-j3wy15.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-05-31 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-05-31T12:00:00+08:00">2023-05-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>25k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>23 分钟</span></span></div><h3><a href="/2023/05/31/ue%E6%BA%90%E7%A0%81/%E6%96%B0%E5%BB%BAniagara%20renderer/" itemprop="url" title="新建niagara renderer">新建niagara renderer</a></h3><div class="excerpt"># 新建 niagara renderer # UNiagaraRendererProperties 这是个 niagara renderer 的资产，通过 Uobject 反射宏机制生成界面，让用户可以实现各种绑定材质和各种参数什么的，就是这东西： 顺便说一下其他一些要用到类对应 niagara 界面控件 FNiagaraVariableAttributeBinding： FNiagaraVariable： 说回 RendererProperties，RendererProperties 要通过函数注册到 Niagara editor 模组里面，这样就可以再 Niagara...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2023/05/31/ue%E6%BA%90%E7%A0%81/%E6%96%B0%E5%BB%BAniagara%20renderer/" itemprop="url" title="新建niagara renderer" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/" itemprop="url" title="RHI解析"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-yx73xg.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-04-16 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-04-16T12:00:00+08:00">2023-04-16</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>9.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>9 分钟</span></span></div><h3><a href="/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/" itemprop="url" title="RHI解析">RHI解析</a></h3><div class="excerpt">RHI 全称是 Render Hardware Interface（渲染硬件接口） ，是 UE 渲染体系中非常基础且重要的模块，封装了众多图形 API（DirectX、OpenGL、Vulkan、Metal）之间的差异，对 Game 和 Renderer 模块提供了简便且一致的概念、数据、资源和接口，实现一份渲染代码跑在多个平台的目标。 开启 RHI 线程的情况下，与 RHI 相伴相随的还有 RHI 线程 ，它负责将渲染线程 Push 进来的 RHI 中间指令转译到对应图形平台的 GPU 指令。在部分图形 API（DX12、Vulkan、主机）支持并行的情况下，如果渲染线程是并行生成的 RHI...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2023/04/16/ue%E6%BA%90%E7%A0%81/RHI%E8%A7%A3%E6%9E%90/" itemprop="url" title="RHI解析" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/04/01/CPPBasicKnowledge/" itemprop="url" title="C++基础知识"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-o33dem.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-04-01 22:33:34"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-04-01T22:33:34+08:00">2023-04-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>3 分钟</span></span></div><h3><a href="/2023/04/01/CPPBasicKnowledge/" itemprop="url" title="C++基础知识">C++基础知识</a></h3><div class="excerpt"># 变量类型 HINSTANCE HINSTANCE 是 Windows 里的一中数据类型，其实就是一个无符号的长整形，是 32 位的，是用于标示（记录）一个程序的实例。它与 HMODULE 是一样的（通用的，这两种类型最终就是无符号长整形）。 HINSTANCE， 分开看就是 H + INSTANCE, 其中 H 代表 HANDLE（再程序中翻译为 “句柄” 的意思），INSTANCE 中文就是 &amp;quot;实例&amp;quot; 的意思。 想得到一个实例， 可通过全局 API 函数 GetModuleHandle 得到，参数传入模块的名字（exe 或者 DLL...</div><div class="meta footer"><span><a href="/categories/C-%E7%AC%94%E8%AE%B0/" itemprop="url" title="C++ 笔记"><i class="ic i-flag"></i>C++ 笔记</a></span></div><a href="/2023/04/01/CPPBasicKnowledge/" itemprop="url" title="C++基础知识" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/02/17/%E7%BE%8E%E6%9C%AF%E8%B4%B4%E5%9B%BE%E8%B5%84%E6%BA%90PBR%E6%B5%81%E7%A8%8B/" itemprop="url" title="美术贴图资源PBR流程"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-dg95r3.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-02-17 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-02-17T12:00:00+08:00">2023-02-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2023/02/17/%E7%BE%8E%E6%9C%AF%E8%B4%B4%E5%9B%BE%E8%B5%84%E6%BA%90PBR%E6%B5%81%E7%A8%8B/" itemprop="url" title="美术贴图资源PBR流程">美术贴图资源PBR流程</a></h3><div class="excerpt"># 美术贴图资源 PBR 流程 # 两种工作流程 Metal / Roughness 容易调参，应用广泛，但是无法调节菲涅尔反射值。 Specular/Glossiness 的话，可以修改菲涅尔值，但是容易破坏能量守恒。 # 金属 / 粗糙度工作流（Metal / Roughness） # base color RGB 贴图 - sRGB 我们通过折射率算出的折射光线是被吸收的光线。对于金属来说部分光线反射，折射光线直接被吸收。金属的颜色来自于折射的光线也就是 F0, 也就是说金属的 F0 就是金属的颜色。 虽然金属度为 1 通常是剖光金属，通常金属可以在 235-255 sRGB...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2023/02/17/%E7%BE%8E%E6%9C%AF%E8%B4%B4%E5%9B%BE%E8%B5%84%E6%BA%90PBR%E6%B5%81%E7%A8%8B/" itemprop="url" title="美术贴图资源PBR流程" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/02/17/simulation/%E5%9F%BA%E4%BA%8ELBM(Lattice%20Boltzmann%20Method)%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/" itemprop="url" title="基于LBM(Lattice Boltzmann Method)流体模拟"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-rd9pv1.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-02-17 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-02-17T12:00:00+08:00">2023-02-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>7.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>7 分钟</span></span></div><h3><a href="/2023/02/17/simulation/%E5%9F%BA%E4%BA%8ELBM(Lattice%20Boltzmann%20Method)%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/" itemprop="url" title="基于LBM(Lattice Boltzmann Method)流体模拟">基于LBM(Lattice Boltzmann Method)流体模拟</a></h3><div class="excerpt"># 基于 LBM (Lattice Boltzmann Method) 流体模拟 相对于基于解 N-S 方程的流体模拟方法，Lattice Boltzmann Method，简称 LBM，LBM 是另外一种截然不同的方法，这种方法和传统解 N-S 方程关系不同，传统方法是纯数值求解，通过逼近域来求解偏微分方程，但大多数求解都局限在二阶精度。LBM 方法避免了传统方法求解流体力学方程的复杂求解及低精度，但也能实现逼真的流体模拟动画，因为不同复杂求解 N-S 方程，所以速度上会快很多，在 3070s 显卡 1024 分辨率仅需 0.06ms，但缺点是显存占用比较多，因为要存 9...</div><div class="meta footer"><span><a href="/categories/%E6%96%87%E7%AB%A0/" itemprop="url" title="文章"><i class="ic i-flag"></i>文章</a></span></div><a href="/2023/02/17/simulation/%E5%9F%BA%E4%BA%8ELBM(Lattice%20Boltzmann%20Method)%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/" itemprop="url" title="基于LBM(Lattice Boltzmann Method)流体模拟" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/02/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E8%96%84%E8%86%9C%E5%B9%B2%E6%B6%89/" itemprop="url" title="薄膜干涉"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-57vkd7.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-02-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-02-07T12:00:00+08:00">2023-02-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>3.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>3 分钟</span></span></div><h3><a href="/2023/02/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E8%96%84%E8%86%9C%E5%B9%B2%E6%B6%89/" itemprop="url" title="薄膜干涉">薄膜干涉</a></h3><div class="excerpt"># 薄膜干涉 # 光程（optical path difference） 先说一下前置知识 光程就是是指在均匀介质中，光行径的几何路径的长度 s 与光在该介质中的折射率 n...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2023/02/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E8%96%84%E8%86%9C%E5%B9%B2%E6%B6%89/" itemprop="url" title="薄膜干涉" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/02/03/ue%E6%BA%90%E7%A0%81/Virtual%20Texture%E8%A7%A3%E6%9E%90/" itemprop="url" title="Virtual Texture解析"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-8o1pzo.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-02-03 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-02-03T12:00:00+08:00">2023-02-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2023/02/03/ue%E6%BA%90%E7%A0%81/Virtual%20Texture%E8%A7%A3%E6%9E%90/" itemprop="url" title="Virtual Texture解析">Virtual Texture解析</a></h3><div class="excerpt"># Virtual Texture 解析 FVirtualTextureSystem 是整个 Virtual Texture 的管理类，几乎所有的 VT 系统的操作都会通过他来进行调度。 FVirtualTextureSpace 用来管理 Page table 的，其数量上有明显的上限，只有 16 个。一个 Page table 资源对应一个 FVirtualTextureSpace 对象。这里限制的原因应该是标志位的限制，我们在 FeedBack 中仅有 4 位留给我们判断属于哪个 Page table。 FVirtualTexturePhysicalSpace 用来管理 Physical...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2023/02/03/ue%E6%BA%90%E7%A0%81/Virtual%20Texture%E8%A7%A3%E6%9E%90/" itemprop="url" title="Virtual Texture解析" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/02/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VirtualTexture/" itemprop="url" title="VirtualTexture"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-5gg681.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-02-03 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-02-03T12:00:00+08:00">2023-02-03</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>3 分钟</span></span></div><h3><a href="/2023/02/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VirtualTexture/" itemprop="url" title="VirtualTexture">VirtualTexture</a></h3><div class="excerpt"># VirtualTexture # 什么是 VirtualTexture 虚拟纹理就是一种以空间换时间的纹理流送技术，好处是可以让我们使用高分辨率贴图不受内存和带宽影响。 传统流送就是在需要使用某张纹理的时候会一次性将对应的 mip 的整个纹理全部加载到 GPU 内存中，即使这个纹理只看到一小部分，这样就会照成巨大的带宽消耗，而虚拟纹理就是把一张大的贴图切成一个个小 page，只有在看到这个 page 的时候才会加载到内存中 # UE 的 VT 虚幻引擎 4 (UE4) 支持两种虚拟纹理方法：运行时虚拟纹理 (RVT) 和 流送虚拟纹理...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2023/02/03/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VirtualTexture/" itemprop="url" title="VirtualTexture" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/01/30/ue%E6%BA%90%E7%A0%81/UEShadowMapRendering/" itemprop="url" title="阴影渲染机制"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-4g62qe.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-01-30 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-01-30T12:00:00+08:00">2023-01-30</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2023/01/30/ue%E6%BA%90%E7%A0%81/UEShadowMapRendering/" itemprop="url" title="阴影渲染机制">阴影渲染机制</a></h3><div class="excerpt"># 阴影初始化 阴影初始化 InitDynamicShadows 的主要过程，如下： 根据 view、场景光源、控制台变量初始化阴影相关标记。 遍历场景所有光源（Scene-&amp;gt;Lights），执行以下操作： 如果光源没有开启阴影或阴影质量太小，或者光源在所有 view 都不可见，忽略之，不执行阴影投射。 如果是点光源全景阴影，则将该光源组件名字加入 Scene 的 UsedWholeScenePointLightNames 列表中。 如果符合全景阴影的创建条件，调用...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2023/01/30/ue%E6%BA%90%E7%A0%81/UEShadowMapRendering/" itemprop="url" title="阴影渲染机制" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/01/09/ShadowMap/" itemprop="url" title="ShadowMap"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-l3kwxr.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-01-09 19:24:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-01-09T19:24:00+08:00">2023-01-09</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>3.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>3 分钟</span></span></div><h3><a href="/2023/01/09/ShadowMap/" itemprop="url" title="ShadowMap">ShadowMap</a></h3><div class="excerpt"># ShadowMap 若用 d 记作物体在 Shadowmap 中采样获取的深度，z 表示物体的光源坐标深度，f 表示阴影值，那么基础 Shadowmap 算法可以表示为： f(z)=H(z−d)f(z)=H(z-d) f(z)=H(z−d) H(x)=0(x≥0),1(x&amp;lt;0)H(x)=0(x&#92;geq0), 1(x&amp;lt;0) H(x)=0(x≥0),1(x&amp;lt;0) # Shadow 这里直接用 scenecapture2d 作为灯光捕捉的深度，传到材质里，同时也把相机的 VP 矩阵也一起传到材质里，做深度对比。 #...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2023/01/09/ShadowMap/" itemprop="url" title="ShadowMap" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2023/01/02/NiagaraDataInterface/" itemprop="url" title="使用自定义Niagara数据接口"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-0wjq1x.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2023-01-02 21:50:27"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2023-01-02T21:50:27+08:00">2023-01-02</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2023/01/02/NiagaraDataInterface/" itemprop="url" title="使用自定义Niagara数据接口">使用自定义Niagara数据接口</a></h3><div class="excerpt"># 使用自定义 Niagara 数据接口 继承自 public UNiagaraDataInterface FNDIMousePositionProxy1234567891011121314151617181920212223242526272829struct FNDIMousePositionProxy : public FNiagaraDataInterfaceProxy&amp;#123;	virtual int32 PerInstanceDataPassedToRenderThreadSize() const override &amp;#123; return...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2023/01/02/NiagaraDataInterface/" itemprop="url" title="使用自定义Niagara数据接口" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/11/29/oit/" itemprop="url" title="【UE5】浅析UE5.1OIT半透明排序算法"><img data-src="https://w.wallhaven.cc/full/z8/wallhaven-z8lmpo.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-11-29 19:24:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-11-29T19:24:00+08:00">2022-11-29</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>1.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/11/29/oit/" itemprop="url" title="【UE5】浅析UE5.1OIT半透明排序算法">【UE5】浅析UE5.1OIT半透明排序算法</a></h3><div class="excerpt"># 前言 UE 在 5.1 更新了 OIT 算法，其算法原理很简单，把半透明重写写入深度进行排序和颜色混合。这里主要记录一些细节和官方的做法，同时也水一篇文章 # 原理 首先 UE 有两种 OIT 排序，一个是 EOITSortingType::SortedTriangles 三角面排序，另一个是 EOITSortingType::SortedPixels # SortedTriangles 其中三角面排序，可以直接在 component...</div><div class="meta footer"><span><a href="/categories/%E6%96%87%E7%AB%A0/" itemprop="url" title="文章"><i class="ic i-flag"></i>文章</a></span></div><a href="/2022/11/29/oit/" itemprop="url" title="【UE5】浅析UE5.1OIT半透明排序算法" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" itemprop="url" title="渲染机制解析"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-95jek8.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-11-13 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-11-13T12:00:00+08:00">2022-11-13</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>18 分钟</span></span></div><h3><a href="/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" itemprop="url" title="渲染机制解析">渲染机制解析</a></h3><div class="excerpt"># 渲染机制解析 类型 解析 UPrimitiveComponent 图元组件，是所有可渲染或拥有物理模拟的物体父类。是 CPU 层裁剪的最小粒度单位。 FPrimitiveSceneProxy 图元场景代理，是 UPrimitiveComponent 在渲染器的代表，镜像了 UPrimitiveComponent 在渲染线程的状态。 FPrimitiveSceneInfo 渲染器内部状态（描述了 FRendererModule 的实现），相当于融合了 UPrimitiveComponent and...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2022/11/13/ue%E6%BA%90%E7%A0%81/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" itemprop="url" title="渲染机制解析" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/11/07/DualKawaseBlur/" itemprop="url" title="【UE4&#x2F;UE5】拓展后期pass实现DualKawaseBlur"><img data-src="https://pic1.zhimg.com/v2-79bce61997eaf687cca50c7dabcb3065_1440w.jpg?source=172ae18b"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-11-07 17:35:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-11-07T17:35:00+08:00">2022-11-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>13k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>11 分钟</span></span></div><h3><a href="/2022/11/07/DualKawaseBlur/" itemprop="url" title="【UE4&#x2F;UE5】拓展后期pass实现DualKawaseBlur">【UE4/UE5】拓展后期pass实现DualKawaseBlur</a></h3><div class="excerpt"># Scene View Extension 在 UE4.17 的时候官方开放了可以在后期插入自己 pass 的接口，那么我们就可以写自己的 shader，甚至可以写 compute shader 去做后期处理。还可以做多 pass。而且使用方式也很简单 我们只需要继承 FSceneViewExtensionBase 12345678910111213class GAMES202_API FDualKawaseBlur : public FSceneViewExtensionBase&amp;#123;public: FDualKawaseBlur(const...</div><div class="meta footer"><span><a href="/categories/%E6%96%87%E7%AB%A0/" itemprop="url" title="文章"><i class="ic i-flag"></i>文章</a></span></div><a href="/2022/11/07/DualKawaseBlur/" itemprop="url" title="【UE4&#x2F;UE5】拓展后期pass实现DualKawaseBlur" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/10/19/%E6%B7%B1%E5%85%A5GPU%E5%92%8C%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%20d4b709561b4345e4b120236c4dd265f4/" itemprop="url" title="深入GPU和渲染优化（基础篇）"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-nzyr7j.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-10-19 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-10-19T12:00:00+08:00">2022-10-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>16 分钟</span></span></div><h3><a href="/2022/10/19/%E6%B7%B1%E5%85%A5GPU%E5%92%8C%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%20d4b709561b4345e4b120236c4dd265f4/" itemprop="url" title="深入GPU和渲染优化（基础篇）">深入GPU和渲染优化（基础篇）</a></h3><div class="excerpt"># 深入 GPU 和渲染优化（基础篇） # 基础概念 GPU架构概述 GPU 架构概述 GPU，全称为 Graphics Processing Unit，即图形处理单元。 GPU 主要包含控制模块，计算模块和输出模块。 渲染输出单元，纹理映射单元和着色器处理单元 / 流处理器 计算模块 计算模块由通用计算单元组成，即 GPGPU，它适用于所有 shader 类型。 TPC 通用计算单元中，最核心的计算模块，称为 Texture Process Cluster (TPC)，它负责： （1）纹理采样 （2）顶点插值，顶点剔除 （3）shader 载入 （4）shader...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/10/19/%E6%B7%B1%E5%85%A5GPU%E5%92%8C%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89%20d4b709561b4345e4b120236c4dd265f4/" itemprop="url" title="深入GPU和渲染优化（基础篇）" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/06/26/MultiPass/" itemprop="url" title="【虚幻引擎】在UE实现多Pass Renderer"><img data-src="https://w.wallhaven.cc/full/yx/wallhaven-yxj26x.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-06-26 15:38:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-06-26T15:38:00+08:00">2022-06-26</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>10 分钟</span></span></div><h3><a href="/2022/06/26/MultiPass/" itemprop="url" title="【虚幻引擎】在UE实现多Pass Renderer">【虚幻引擎】在UE实现多Pass Renderer</a></h3><div class="excerpt"># 前言 在 ue 里面实现多 pass 比我想象中要简单，并不需要改引擎既可以实现。多 pass 本质上其实就是模型多画一次，所以 ue 需要多 pass 时候只要把模型多复制一份出来就好了，但这样显得有些些蠢，而且 drawcall 也会增加，所以这篇文章就是介绍基于图元多插入一个或多个 Material 来实现多 pass。 # 讲解 首先介绍一下 UE 的模型渲染机制 首先可以看到上图，网格体渲染从 FPrimitiveSceneProxy 开始，FPrimitiveSceneProxy 负责通过对 GetDynamicMeshElements 和...</div><div class="meta footer"><span><a href="/categories/%E6%96%87%E7%AB%A0/" itemprop="url" title="文章"><i class="ic i-flag"></i>文章</a></span></div><a href="/2022/06/26/MultiPass/" itemprop="url" title="【虚幻引擎】在UE实现多Pass Renderer" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/05/18/ue%E6%BA%90%E7%A0%81/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" itemprop="url" title="智能指针"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-xl1g53.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-05-18 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-05-18T12:00:00+08:00">2022-05-18</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>3.7k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>3 分钟</span></span></div><h3><a href="/2022/05/18/ue%E6%BA%90%E7%A0%81/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" itemprop="url" title="智能指针">智能指针</a></h3><div class="excerpt"># 智能指针 UObject 本身就可以帮我们做回收，做释放的，为了可以在更好释放内存，避免出现野指针，而出现智能指针 # 为什么使用虚幻 4 的智能指针库？ std::shared_ptr 不是在所有的平台都能用的 可以和其它虚幻容器及类型无缝协作 更好的控制平台特性，包括线程处理和优化 # 优点 可以像常规的 C++ 指针那样复制，解引用，比较共享指针等 防止内存泄漏：当没有共享引用时资源自动删除 包含了可以通过多线程安全地进行访问的 “线程安全” 版本 可以创建任何类型的对象的共享指针 支持针 “const”、前置声明的不完全类型、类型转换等 #...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2022/05/18/ue%E6%BA%90%E7%A0%81/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" itemprop="url" title="智能指针" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/19/Lumen/" itemprop="url" title="Lumen"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-6o6jwq.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-19 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-19T12:00:00+08:00">2022-04-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>7.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>7 分钟</span></span></div><h3><a href="/2022/04/19/Lumen/" itemprop="url" title="Lumen">Lumen</a></h3><div class="excerpt"># Lumen Lumen 是各种 GI 技术的整合，可以简单概括成 SDF (Mesh 距离场 + 全局距离场) + “体素”（Surface Cache） + SSGI （屏幕空间追踪）+ RSM (Reflective Shadow Map) + 硬件光追（lumen 补充） SDF (Mesh 距离场 + 全局距离场): 软光追加速结构，其中 Mesh 距离场在 UE4 里已被用于 DFAO，而全局距离场是一张合并了相附近所有 Mesh 距离场的 texture，为了避免遍历每个网格距离场的一种 “低配” 方案；这俩正好对应项目设置里的两种追踪模式：Detail Tracing 和...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/19/Lumen/" itemprop="url" title="Lumen" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/19/Nanite/" itemprop="url" title="Nanite"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-dpw3wg.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-19 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-19T12:00:00+08:00">2022-04-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>5.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>5 分钟</span></span></div><h3><a href="/2022/04/19/Nanite/" itemprop="url" title="Nanite">Nanite</a></h3><div class="excerpt"># Nanite 基于 Mesh Shader 的 Pipeline，Cluster 剔除成为了顶点处理阶段的一部分，减少没必要的 Vertex Buffer Load/Store Nanite 把实现分成两个过程三个部分: 预处理过程：在模型导入或者在引擎中修改模型设置时处理，把高模预处理成一簇簇的三角形簇，建立分层分页结构用于渲染和加载 把模型分成 Cluster, 类似 Meshshader 中的 Meshlet。划分在拓扑空间中邻近的 Cluster，是为了提高访问数据时 Cache 命中率。Cluster 分割使用 Metis 库把模型的顶点数据进一步切分为更细粒度的...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/19/Nanite/" itemprop="url" title="Nanite" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/UnifomBuffer/" itemprop="url" title="UnifomBuffer"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-m91xk1.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-10 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-10T12:00:00+08:00">2022-04-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>192</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/UnifomBuffer/" itemprop="url" title="UnifomBuffer">UnifomBuffer</a></h3><div class="excerpt"># UnifomBuffer Uniform Buffer 涉及了几个核心的概念，最底层的是 RHI 层的 FRHIUniformBuffer，封装了各种图形 API 的统一缓冲区（也叫 Constant Buffer） 如果项目处于开发阶段，最好将 Shader 的编译选项改成 Development，可以通过修改 Engine&#92;Config&#92;ConsoleVariables.ini</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/UnifomBuffer/" itemprop="url" title="UnifomBuffer" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E4%BC%98%E5%8C%96/" itemprop="url" title="shader优化"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-o32gz9.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-10 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-10T12:00:00+08:00">2022-04-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>766</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E4%BC%98%E5%8C%96/" itemprop="url" title="shader优化">shader优化</a></h3><div class="excerpt"># shader 优化 避免 if、switch 分支语句。 避免 for 循环语句，特别是循环次数可变的。 减少纹理采样次数。 禁用 clip 或 discard 操作。 减少复杂数学函数调用。 使用更低精度的浮点数。OpenGL ES 的浮点数有三种精度：highp（32 位浮点）, mediump（16 位浮点）, lowp（8 位浮点），很多计算不需要高精度，可以改成低精度浮点。 充分利用向量分量掩码。 避免重复计算。可以将所有像素一样的变量提前计算好，或者由 C++ 层传入： ・向量延迟计算。 避免或减少临时变量。 尽量将 Pixel Shader 计算移到...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E4%BC%98%E5%8C%96/" itemprop="url" title="shader优化" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E7%BC%96%E8%AF%91/" itemprop="url" title="shader编译"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-4gkve3.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-10 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-10T12:00:00+08:00">2022-04-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>449</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E7%BC%96%E8%AF%91/" itemprop="url" title="shader编译">shader编译</a></h3><div class="excerpt"># shader 编译 shader 的编译是由 RecompileShader 命令去处理过程，里面是 BeginRecompileGlobalShaders 开始编译指定的 shader，shader 的编译作业由全局对象 GShaderCompilingManager 完成，最终的 shader 编译作业实例类型是 FShaderCommonCompileJob，它的实例对进入一个全局的队列，以便多线程异步地编译。 FShaderCompilingManager::AddJobs 等接口加入到 FShaderCompilingManager::CompileQueue 队列中，然后主要由...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/10/ue%E6%BA%90%E7%A0%81/shader%E7%BC%96%E8%AF%91/" itemprop="url" title="shader编译" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/08/Softbody/" itemprop="url" title="【UE5】在niagara实现Softbody dynamic"><img data-src="https://picx.zhimg.com/v2-fa0f656bfc72e1635473a5a545572c73_1440w.jpg?source=172ae18b"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-08 18:34:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-08T18:34:00+08:00">2022-04-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2022/04/08/Softbody/" itemprop="url" title="【UE5】在niagara实现Softbody dynamic">【UE5】在niagara实现Softbody dynamic</a></h3><div class="excerpt">最近疫情被锁在家里半个月多月，有点无聊总想搞点什么，就突然想到我模拟这块在 niagara 上已经做过了基于欧拉视角的 NS 公式和 SPH 模拟流体，还有基于 PBD 的 rigid body dynamics，用 jocobi 迭代隐式积分求解 Mass-spring systems，都是基于 GPU 的效果，无奈 niagara 是个方便的 compute shader，就想着还有什么效果没做过的，就想到个 softbody，前面流体的 niagara 文章在知乎很多大佬都写过，在 b 站也有解析教程，但反观 rigidbody 和 softbody 的 niagara...</div><div class="meta footer"><span><a href="/categories/%E6%96%87%E7%AB%A0/" itemprop="url" title="文章"><i class="ic i-flag"></i>文章</a></span></div><a href="/2022/04/08/Softbody/" itemprop="url" title="【UE5】在niagara实现Softbody dynamic" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/GPU/" itemprop="url" title="GPU"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-57vkd7.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>5.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>5 分钟</span></span></div><h3><a href="/2022/04/07/GPU/" itemprop="url" title="GPU">GPU</a></h3><div class="excerpt"># GPU # SIMD SIMD (Single Instruction Multiple Data) 单指令多数据，例如多维向量 ，c++ 里 SSE 就是调用单指令多数据 SIMT(single Instruction Multiple Threads) 单指令多线程，可对 GPU 中单个 SM 中的多个 Core 同时处理同一指令，并且每个 Core 存取的数据可以是不同的。 GPC (图形处理集群) 计算、栅格化、阴影和纹理处理。40 系列安培架构里面还塞了 AI，还有光追 SM  (流式多处理器)      运行 CUDA 内核的 GPU 的一部分 SFU（Special...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/GPU/" itemprop="url" title="GPU" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/FEM(%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90)/" itemprop="url" title="FEM(有限元分析)"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-9m2q98.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>14k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>13 分钟</span></span></div><h3><a href="/2022/04/07/simulation/FEM(%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90)/" itemprop="url" title="FEM(有限元分析)">FEM(有限元分析)</a></h3><div class="excerpt"># FEM (有限元分析) X10 ，x20,x30 竖向量写入矩阵，逆矩阵后行列式 * 1/6 是四面体面值 大 X 是形变前，小 x 是形变后 矩阵的迹是对角线相加 µ 和 λ 自定义输入，为摩擦力 F0 = -f1...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/FEM(%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90)/" itemprop="url" title="FEM(有限元分析)" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/GJK%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/" itemprop="url" title="GJK碰撞检测"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-9m2lww.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>9.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>9 分钟</span></span></div><h3><a href="/2022/04/07/simulation/GJK%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/" itemprop="url" title="GJK碰撞检测">GJK碰撞检测</a></h3><div class="excerpt"># GJK 碰撞检测 闵可夫斯基和是两个欧几里得空间的点集的和，也称为这两个空间的膨胀集， 例如，平面上有两个三角形，其坐标分别为 A={(1,0),(0,1),(0,-1)} 及 B = {(0, 0), (1, 1), (1, −1)}，则其闵可夫斯基和为 A + B= {(1, 0), (2, 1), (2, −1), (0, 1), (1, 2), (1, 0), (0, −1), (1, 0), (1, −2)}。 若推广至流形的连续集，闵可夫斯基和从几何上的直观体现即是 A 集合沿 B 的边际连续运动一周扫过的区域与 B 集合本身的并集，也可以是 B 沿着 A...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/GJK%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/" itemprop="url" title="GJK碰撞检测" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/Laplacian%E7%AE%97%E5%AD%90%EF%BC%88%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90%EF%BC%89/" itemprop="url" title="Laplacian算子（拉普拉斯算子）"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-57vkd7.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>1.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2022/04/07/simulation/Laplacian%E7%AE%97%E5%AD%90%EF%BC%88%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90%EF%BC%89/" itemprop="url" title="Laplacian算子（拉普拉斯算子）">Laplacian算子（拉普拉斯算子）</a></h3><div class="excerpt"># Laplacian 算子（拉普拉斯算子） 在數學以及物理中，拉普拉斯算子或是拉普拉斯算符（英語：Laplace operator, Laplacian ）是由欧几里得空间中的一個函数的梯度的散度给出的微分算子，通常写成 Δ、∇2或∇⋅∇{&#92;displaystyle &#92;Delta }、{&#92;displaystyle &#92;nabla ^{2}}或{&#92;displaystyle &#92;nabla &#92;cdot &#92;nabla...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/Laplacian%E7%AE%97%E5%AD%90%EF%BC%88%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90%EF%BC%89/" itemprop="url" title="Laplacian算子（拉普拉斯算子）" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/Rigid%20body/" itemprop="url" title="Rigid body"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-dpokm3.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>7.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>7 分钟</span></span></div><h3><a href="/2022/04/07/simulation/Rigid%20body/" itemprop="url" title="Rigid body">Rigid body</a></h3><div class="excerpt"># Rigid body 角速度 = 点的 vector *rotate matrix（随着力矩变化而变化）cross force vector，就是旋转轴，抵抗质量总和起来是因为每个质量离力矩不同所产生抵抗不同，旋转矩阵 R 每一帧随着力矩改变 角速度质量 I ref 是所有顶点质量的总和 ri 转置矩阵乘 ri 是等于 ri 长度 1 为单位矩阵 # Impose 碰撞 Impose 方法致力于即时的反应，并且考虑了库伦定律的作用，因此计算摩擦相对容易。 Impose 方法认为刚体满足其最基本的定义：无法产生形变，因此 impose 方法严格按照碰撞方程进行。 假设发生碰撞，则...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/Rigid%20body/" itemprop="url" title="Rigid body" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2%E5%87%BD%E6%95%B0/" itemprop="url" title="双边滤波函数"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-kwly77.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>2.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>2 分钟</span></span></div><h3><a href="/2022/04/07/simulation/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2%E5%87%BD%E6%95%B0/" itemprop="url" title="双边滤波函数">双边滤波函数</a></h3><div class="excerpt"># 双边滤波函数 既然高斯模糊没有良好地保留边界，我们就选取一个能够保边去噪的滤波器，高斯双边滤波算法就是这样的一个滤波器。高斯模糊仅仅考虑了像素的空间分布，权重从中间向周边降低。而双边滤波则进一步考虑了图像的像素值，从而保证边缘部分不会被过滤掉。根据维基百科...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2%E5%87%BD%E6%95%B0/" itemprop="url" title="双边滤波函数" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/%E6%A0%BC%E6%8B%89%E5%A7%86-%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96/" itemprop="url" title="格拉姆-施密特正交化"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-mdgp8y.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>782</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/simulation/%E6%A0%BC%E6%8B%89%E5%A7%86-%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96/" itemprop="url" title="格拉姆-施密特正交化">格拉姆-施密特正交化</a></h3><div class="excerpt"># 格拉姆 - 施密特正交化 在线性代数中，如果内积空间上的一组向量能够组成一个子空间，那么这一组向量就称为这个子空间的一个基。Gram－Schmidt 正交化提供了一种方法，能够通过这一子空间上的一个基得出子空间的一个正交基，并可进一步求出对应的标准正交基。 这种正交化方法以约尔根・佩德森・格拉姆和艾哈德・施密特命名，然而比他们更早的拉普拉斯（Laplace）和柯西（Cauchy）已经发现了这一方法。在李群分解中，这种方法被推广为岩泽分解（Iwasawa decomposition）。 在数值计算中，Gram－Schmidt...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/%E6%A0%BC%E6%8B%89%E5%A7%86-%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96/" itemprop="url" title="格拉姆-施密特正交化" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/%E8%B4%A8%E7%82%B9%E5%BC%B9%E7%B0%A7%E7%B3%BB%E7%BB%9F/" itemprop="url" title="质点弹簧系统"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-v96x8p.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>46</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/simulation/%E8%B4%A8%E7%82%B9%E5%BC%B9%E7%B0%A7%E7%B3%BB%E7%BB%9F/" itemprop="url" title="质点弹簧系统">质点弹簧系统</a></h3><div class="excerpt"># 质点弹簧系统 ｜Xi-Xj｜现 2 个点的距离，Lji 弹簧静止距离 (Xi-Xj) 方向</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/%E8%B4%A8%E7%82%B9%E5%BC%B9%E7%B0%A7%E7%B3%BB%E7%BB%9F/" itemprop="url" title="质点弹簧系统" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/simulation/%E7%9F%A9%E9%98%B5/" itemprop="url" title="矩阵"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-3l9p1v.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>442</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/simulation/%E7%9F%A9%E9%98%B5/" itemprop="url" title="矩阵">矩阵</a></h3><div class="excerpt"># 矩阵 逆矩阵 = 伴随矩阵 * 1 / 矩阵的行列式值（绝对值） 伴随矩阵 = 余子式矩阵对角变换 https://www.shuxuele.com/algebra/matrix-inverse-minors-cofactors-adjugate.html # 矩阵的行列式值求法 |A | 代表矩阵 A 的行列式和绝对值的符号一样 矩阵的行列式 行列式的几何意义是面积体积，2x2 矩阵的行列式是平行四边形的面积，3x3 矩阵的行列式是正方体也就是六面体的体积，行列式也代表线性变化的缩放程度，大于 1 则放大...</div><div class="meta footer"><span><a href="/categories/%E6%A8%A1%E6%8B%9F%E7%AC%94%E8%AE%B0/" itemprop="url" title="模拟笔记"><i class="ic i-flag"></i>模拟笔记</a></span></div><a href="/2022/04/07/simulation/%E7%9F%A9%E9%98%B5/" itemprop="url" title="矩阵" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/ue%E6%BA%90%E7%A0%81/%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/" itemprop="url" title="材质系统解析"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-839721.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>7.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>7 分钟</span></span></div><h3><a href="/2022/04/07/ue%E6%BA%90%E7%A0%81/%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/" itemprop="url" title="材质系统解析">材质系统解析</a></h3><div class="excerpt"># 材质系统解析 UMaterial 是 material 的资源，就是我们在 constant 上的 material，material 真正被用于运算的好似 UMaterialInterface。UMaterialInterface 是材质的基类，UMaterial 和 UMaterialInstance 都派生自它 一个 UMaterial 里面会有很多 FMaterial，一个 FMaterial 会存储特定平台，特定质量等级的 Shader 和资源，因为一个 UMaterial 有很多平台，质量等级的储存需求，所以会存很多 FMaterial。 FMaterialResource 是...</div><div class="meta footer"><span><a href="/categories/UE%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" itemprop="url" title="UE 源码笔记"><i class="ic i-flag"></i>UE 源码笔记</a></span></div><a href="/2022/04/07/ue%E6%BA%90%E7%A0%81/%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/" itemprop="url" title="材质系统解析" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Ambient%20Cube%20074e81bf559f43b48fa72e7c2635eae7/" itemprop="url" title="Ambient Cube"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-v96x8p.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>263</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Ambient%20Cube%20074e81bf559f43b48fa72e7c2635eae7/" itemprop="url" title="Ambient Cube">Ambient Cube</a></h3><div class="excerpt"># Ambient Cube ambient cube 是 valve 在 2004 年开发半条命 2 使用的一个提供间接光的技术。该方法的资料不多，核心思想是将一个 vpl 看作一个 cube。cube 有六个面，每个面中存放相对于的颜色。在 evaluation 阶段，通过法线去索引这六个面中的 3 个面，最后通过权重去做混合。 六个 float3 的参数，带宽占用在 2 阶球谐和 3 阶球谐之间。效果基本上和 2 阶球谐一样。优势在于 evaluation 阶段，alu 开销小于 2 阶球谐，在移动端中的性能要好一些。</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Ambient%20Cube%20074e81bf559f43b48fa72e7c2635eae7/" itemprop="url" title="Ambient Cube" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Compute%20shader%20ce8a4f41e18845b0ac4fb1978f28869f/" itemprop="url" title="Compute shader"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-5773r9.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>1.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Compute%20shader%20ce8a4f41e18845b0ac4fb1978f28869f/" itemprop="url" title="Compute shader">Compute shader</a></h3><div class="excerpt"># Compute shader View 的话有以下几种： ID3D11ConstantBufferView（CBV），表示 Resource 是只读的 Buffer。 ID3D11ShaderResourceView（SRV），表示 Resource 是只读的 Texture。 Compute shader ce8a4f41e18845b0ac4fb1978f28869f.md ID3D11RenderTargetView（RTV），表示 Resource 是只写的 RenderTarget。 ID3D11DepthStencilView（DSV），表示 Resource 是只写的...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Compute%20shader%20ce8a4f41e18845b0ac4fb1978f28869f/" itemprop="url" title="Compute shader" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/BRDF%E6%96%B9%E7%A8%8B%2070512469e005449dab1f3eb91452f787/" itemprop="url" title="BRDF方程"><img data-src="/2022/04/07/图形学笔记/BRDF方程 70512469e005449dab1f3eb91452f787/Untitled 1.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>4.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>4 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/BRDF%E6%96%B9%E7%A8%8B%2070512469e005449dab1f3eb91452f787/" itemprop="url" title="BRDF方程">BRDF方程</a></h3><div class="excerpt"># BRDF 方程 小数字 0 为观察视觉，i 为入射角，Li 为 radiance 这里的 “kd” 是入射光线中被折射部分的能量所占的比率，而 “ks” 是被反射部分的比率。 法线分布函数 D 项 在现代引擎中流行和常用的 NDF 为 GGX (Trowbridge-Reitz) 法线分布函数。D (h) 来描述组成表面一点 的所有微表面的法线分布概率。则可以这样理解：向 NDF 输入一个朝向 h, 这个 h 向量为法线 dot 半向量（view direction 加 light direction），NDF 会返回朝向 是 h 的微表面数占微表面总数的比例，a 为...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/BRDF%E6%96%B9%E7%A8%8B%2070512469e005449dab1f3eb91452f787/" itemprop="url" title="BRDF方程" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/GTAO%20cdb7d5c086e44d4ca1489b7b64c373a0/" itemprop="url" title="GTAO"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-7ppee9.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>121</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/GTAO%20cdb7d5c086e44d4ca1489b7b64c373a0/" itemprop="url" title="GTAO">GTAO</a></h3><div class="excerpt"># GTAO 每个像素点向周围打一个锥形，锥形为固定值，最后求出的值相加 图中距离越远贡献越小 每个 step max 上一个 step 求出最大水平角 h1 和 h2 同时打出去，求他们最大夹角 UE4 Mobile GTAO 实现 (HBAO 续)</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/GTAO%20cdb7d5c086e44d4ca1489b7b64c373a0/" itemprop="url" title="GTAO" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HZB%20(Hierarchical%20Z-Buffer)%2084e7171093be454f8b86d1d03ac2310b/" itemprop="url" title="HZB (Hierarchical Z-Buffer)"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-nzyr7j.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>267</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HZB%20(Hierarchical%20Z-Buffer)%2084e7171093be454f8b86d1d03ac2310b/" itemprop="url" title="HZB (Hierarchical Z-Buffer)">HZB (Hierarchical Z-Buffer)</a></h3><div class="excerpt"># HZB (Hierarchical Z-Buffer) HZB 是多 Mip 层级的 z-buffer，也就是说 depthmap 的 lod，每个更高级别 Mip 的 buffer 记录上一级别中周围四点中最远处的深度值。 将 HZB 生成后，就可以将待剔除物体的包围盒信息传入到 Computer Shader 中进行计算，计算时会选择最适合的 Mip 级别进行遮挡测试。在屏幕中占比更大的物体会选择更高级别 Mip 的深度进行测试，这样可以降低计算量。 计算 hzb 时候的计算了是非常小的，昂贵的是从 gpu 传输到 cpu 上</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HZB%20(Hierarchical%20Z-Buffer)%2084e7171093be454f8b86d1d03ac2310b/" itemprop="url" title="HZB (Hierarchical Z-Buffer)" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" itemprop="url" title="HLSL语言基础"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/pia01322.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>34k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>31 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" itemprop="url" title="HLSL语言基础">HLSL语言基础</a></h3><div class="excerpt"># HLSL 语言基础 HLSL(High-Level Shading Language， 高级着色语言) 是由微软开发的一种着色器语言，D3D9 及以上版本使用其作为着色语言（注：D3D8 的 shader 使用是类似于汇编的语言来编写），拥有如下特点： 基于 C 语言的语法（如：大小写敏感，每条语句必须以分号结尾），是一门面向过程的强类型语言（type sensitive language） 除了 bool、int、uint、half、float、double 基础类型外，还支持数组类型，另外 HLSL 还内置了适合 3D...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/HLSL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" itemprop="url" title="HLSL语言基础" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/MVP%E7%9F%A9%E9%98%B5%20474772934c4146dcb4cddcb94c7b48a4/" itemprop="url" title="MVP矩阵"><img data-src="https://w.wallhaven.cc/full/o3/wallhaven-o3er65.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>388</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/MVP%E7%9F%A9%E9%98%B5%20474772934c4146dcb4cddcb94c7b48a4/" itemprop="url" title="MVP矩阵">MVP矩阵</a></h3><div class="excerpt"># MVP 矩阵 # Ue4 project matrix N/near 为近裁片面到相机的距离，f 为远裁屏幕到相机的距离，fovV 为上下角度，fovH 为左右宽度，ue 设置的 fov 主要是设置 fovH。 投影矩阵推到： [图形学笔记] 推导投影矩阵 在顶点经过投影矩阵变换后变为裁剪空间，之所以称为裁剪空间，是因为基于以上裁剪空间坐标，将 x、y、z 和 [-w,+w] 比较，其中 w = -z，这个 z 是顶点在 View Space 中的 z 值（为了满足投影性质推导出来的值，这里负号因为推导用的 View Space 是右手坐标系，NDC 是左手坐标系）是个超过 1...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/MVP%E7%9F%A9%E9%98%B5%20474772934c4146dcb4cddcb94c7b48a4/" itemprop="url" title="MVP矩阵" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/SH%E6%B1%82%E8%B0%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AB%8B%E4%BD%93%E8%A7%92%20ea839e75f76f4b02bfaf515e79810f44/" itemprop="url" title="SH求谐函数与立体角"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-83lk1j.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>6.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>6 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/SH%E6%B1%82%E8%B0%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AB%8B%E4%BD%93%E8%A7%92%20ea839e75f76f4b02bfaf515e79810f44/" itemprop="url" title="SH求谐函数与立体角">SH求谐函数与立体角</a></h3><div class="excerpt"># SH 求谐函数与立体角 # 直角坐标系转球面坐标系 球坐标转 uv 12345678910111213141516//uv转vectorfloat4 UniformSampleSphere( float2 E )&amp;#123;	float Phi = 2 * PI * E.x;	float CosTheta = 1 - 2 * E.y;	float SinTheta = sqrt( 1 - CosTheta * CosTheta );	float3 H;	H.x = SinTheta * cos( Phi );	H.y = SinTheta * sin( Phi );	H.z...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/SH%E6%B1%82%E8%B0%90%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AB%8B%E4%BD%93%E8%A7%92%20ea839e75f76f4b02bfaf515e79810f44/" itemprop="url" title="SH求谐函数与立体角" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/TAA%20fefed9e1f12f4d78a64918dcba545d9d/" itemprop="url" title="TAA"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-72yjl9.png"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>6.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>6 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/TAA%20fefed9e1f12f4d78a64918dcba545d9d/" itemprop="url" title="TAA">TAA</a></h3><div class="excerpt"># TAA TAA 原理是通过 Motion Vector，找到上一帧的当前像素点的信息，然后混合，因为上一帧信息有很大概率还会出现在屏幕内。同时，对投影矩阵使用 noise 进行半个像素距离的偏移，使得每一帧的投影矩阵与上一帧都不一样，也就相当于混合了多次采样的结果，实现超级采样。 在采样的时候可以用周围 8 格，此时要是上一帧的投影矩阵 projection 到当前帧 uv 是在屏幕外面的话，可以用模糊 123456789101112131415161718float3filter(float3samples[9])&amp;#123;#if...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/TAA%20fefed9e1f12f4d78a64918dcba545d9d/" itemprop="url" title="TAA" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VXGI%20bac8f80de4544dd7b5e7741bab2ab299/" itemprop="url" title="VXGI"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-l3dpdq.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>1.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VXGI%20bac8f80de4544dd7b5e7741bab2ab299/" itemprop="url" title="VXGI">VXGI</a></h3><div class="excerpt"># VXGI Lumen 中的 VoxelLighting 和 VXGI 类似，使⽤是基于 3D Clipmap 的⽅式以节省存储空间。但 Lumen 的 VoxelLighting 中的每个 3D 纹素和 VXGI 中的 Voxel 并不相同 ——Lumen 的每个 3D 纹理表⽰的是 Ambient Cube 某⼀个⽅向上的光照投射参数，实际上它所需要的 3D 纹素数量是其 Size 的 6 倍。这⼉可以看到 VoxelLighting 选择了和 MeshCards ⼏乎完全相同的结构 (六⾯体) 和基函数 (AmbientCube) VoxelLighting 默认使⽤ 4 级 3d...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/VXGI%20bac8f80de4544dd7b5e7741bab2ab299/" itemprop="url" title="VXGI" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Visibility%20Buffer%20328fe9588ec5451faf76588581bfd0b1/" itemprop="url" title="Visibility Buffer"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-j3mpoq.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>1.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Visibility%20Buffer%20328fe9588ec5451faf76588581bfd0b1/" itemprop="url" title="Visibility Buffer">Visibility Buffer</a></h3><div class="excerpt"># Visibility Buffer Visibility Buffer 解决了传统延迟渲染的几个问题： 带宽高； 对于可见性和着色阶段的不完美的分离，会造成 Overdraw； 不能使用 MSAA。 Visibility Buffer 通常需要这些信息： （1）InstanceID，表示当前像素属于哪个 Instance（16~24 bits）； （2）PrimitiveID，表示当前像素属于 Instance 的哪个三角形（8~16 bits）； （3）Barycentric Coord，代表当前像素位于三角形内的位置，用重心坐标表示（16 bits）； （4）Depth...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/Visibility%20Buffer%20328fe9588ec5451faf76588581bfd0b1/" itemprop="url" title="Visibility Buffer" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/" itemprop="url" title="图片压缩算法"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-1pgwov.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>5k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>5 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/" itemprop="url" title="图片压缩算法">图片压缩算法</a></h3><div class="excerpt"># 图片压缩算法 # DXTC DXTC（或 BC）为微软为 DX 而推出的基于 block 的贴图压缩格式，其主要采用调色板的原理来进行压缩。 BC1: 基于 4x4block 来进行，不含有 alpha 通道，每个 block 内记录两个 16bits 的颜色做为基准颜色，然后解压时再使用两个基准色调制出另外两个颜色做为块内 4 个压缩颜色。其计算方式为： basecolor2 = 2/3 *basecolor0 + 1/3 * basecolor1 basecolro3 = 1/3 *basecolor0 + 2/3 * basecolor1 对于每个块内的 texel，存储 2bits...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/" itemprop="url" title="图片压缩算法" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%85%B3%204cf01f6c2d37404ba421f52a0d30f0cc/" itemprop="url" title="旋转相关"><img data-src="https://w.wallhaven.cc/full/k7/wallhaven-k752qd.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>140</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%85%B3%204cf01f6c2d37404ba421f52a0d30f0cc/" itemprop="url" title="旋转相关">旋转相关</a></h3><div class="excerpt"># 旋转相关 # 欧拉角 to 旋转矩阵 # 欧拉角变四元数 # 四元数 四元数是个超复数 满足 i^2 = j2=k2 = -1，四元数 P=a+bi+cj+dk（I 绕 x 旋转，j 绕 y 旋转，k 绕 z 旋转）abcd 均为实数， 虚数是 z = a+bi. , i^2 = -1</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%85%B3%204cf01f6c2d37404ba421f52a0d30f0cc/" itemprop="url" title="旋转相关" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9%205b7a33b443b4469482b32406094b9773/" itemprop="url" title="图形学笔记杂项"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-dg95r3.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>969</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>1 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9%205b7a33b443b4469482b32406094b9773/" itemprop="url" title="图形学笔记杂项">图形学笔记杂项</a></h3><div class="excerpt"># 杂项 # 求曲率 &quot;&quot;12345678float curvature(float3 VertexNormal,float3 WorldPositon)&amp;#123; float DeltaN = length(abs(DDX(VertexNormal)+DDY(VertexNormal))); float DeltaP = length(abs(DDX(WorldPositon)+DDY(WorldPositon))); float curvature = DeltaN / DeltaP ; reture curvature ;&amp;#125; #...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E6%9D%82%E9%A1%B9%205b7a33b443b4469482b32406094b9773/" itemprop="url" title="图形学笔记杂项" class="btn">more...</a></div></article><article class="item"><div class="cover"><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%204c6a1b50e90841d3b3e7ce5734c4210b/" itemprop="url" title="空间结构划分"><img data-src="https://github.com/Natsuneko3/wallpaperLibrary/raw/main/wallhaven-1kxxz3.jpg"></a></div><div class="info"><div class="meta"><span class="item" title="创建时间：2022-04-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><time itemprop="dateCreated datePublished" datetime="2022-04-07T12:00:00+08:00">2022-04-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span>3.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span>3 分钟</span></span></div><h3><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%204c6a1b50e90841d3b3e7ce5734c4210b/" itemprop="url" title="空间结构划分">空间结构划分</a></h3><div class="excerpt"># 空间结构划分 # 层次包围盒 | Bounding Volume Hierarchies , BVH 层次包围盒（Bounding Volume Hierarchies, BVH）方法的核心思想是用体积略大而几何特征简单的包围盒来近似地描述复杂的几何对象，从而只需对包围盒重叠的对象进行进一步的相交测试。此外，通过构造树状层次结构，可以越来越逼近对象的几何模型，直到几乎完全获得对象的几何特征。 对于三维场景的实时渲染来说，层次包围体（Bounding Volume...</div><div class="meta footer"><span><a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url" title="图形学笔记"><i class="ic i-flag"></i>图形学笔记</a></span></div><a href="/2022/04/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%204c6a1b50e90841d3b3e7ce5734c4210b/" itemprop="url" title="空间结构划分" class="btn">more...</a></div></article></div></div><nav class="pagination"><div class="inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="ic i-angle-right" aria-label="下一页"></i></a></div></nav></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Natsuneko" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Natsuneko</p><div class="description" itemprop="description">主要分享关于 ue 或者 TA 的知识，也或者分享点自己想写的东西，作品什么的</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">61</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL05hdHN1bmVrbzM=" title="https:&#x2F;&#x2F;github.com&#x2F;Natsuneko3"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9uYXRzdW5la29zYW4=" title="https:&#x2F;&#x2F;twitter.com&#x2F;natsunekosan"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9OYXRzdW5la28=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;Natsuneko"><i class="ic i-zhihu"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVhbHRpbWUueHl6Lw=="><i class="ic i-heart"></i>friends</span></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/page/2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Natsuneko @ Natsu neko</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">298k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:31</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"",favicon:{show:"（●´3｀●）感觉还不错把",hide:"____________________________________"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(_){return _.includes("#")},function(_){return new RegExp(LOCAL.path+"$").test(_)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>