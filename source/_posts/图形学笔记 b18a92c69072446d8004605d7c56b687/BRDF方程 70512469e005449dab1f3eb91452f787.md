---
title: BRDFæ–¹ç¨‹
date: 2022-04-07 12:00
count: true
math: true
tags: 
- å›¾å½¢å­¦ç¬”è®°
- æ¸²æŸ“
category: å›¾å½¢å­¦ç¬”è®°
cover: Untitled 1.png
---
# BRDFæ–¹ç¨‹

![Untitled](Untitled.png)

å°æ•°å­—0ä¸ºè§‚å¯Ÿè§†è§‰ï¼Œiä¸ºå…¥å°„è§’ï¼ŒLiä¸ºradiance
![Untitled](Untitled%201.png)

è¿™é‡Œçš„â€œkdâ€æ˜¯å…¥å°„å…‰çº¿ä¸­è¢«æŠ˜å°„éƒ¨åˆ†çš„èƒ½é‡æ‰€å çš„æ¯”ç‡ï¼Œè€Œâ€œksâ€æ˜¯è¢«åå°„éƒ¨åˆ†çš„æ¯”ç‡ã€‚

![Untitled](Untitled%202.png)

![Untitled](Untitled%203.png)

æ³•çº¿åˆ†å¸ƒå‡½æ•°Dé¡¹

![Untitled](Untitled%204.png)

åœ¨ç°ä»£å¼•æ“ä¸­æµè¡Œå’Œå¸¸ç”¨çš„NDFä¸ºGGX(Trowbridge-Reitz)æ³•çº¿åˆ†å¸ƒå‡½æ•°ã€‚D(h)æ¥æè¿°ç»„æˆè¡¨é¢ä¸€ç‚¹ çš„æ‰€æœ‰å¾®è¡¨é¢çš„æ³•çº¿åˆ†å¸ƒæ¦‚ç‡ã€‚åˆ™å¯ä»¥è¿™æ ·ç†è§£:å‘ NDF è¾“å…¥ä¸€ä¸ªæœå‘ h,è¿™ä¸ªhå‘é‡ä¸ºæ³•çº¿dotåŠå‘é‡ï¼ˆview direction åŠ  light directionï¼‰ï¼ŒNDF ä¼šè¿”å›æœå‘ æ˜¯ h çš„å¾®è¡¨é¢æ•°å å¾®è¡¨é¢æ€»æ•°çš„æ¯”ä¾‹ï¼Œaä¸ºroughness,ä½†åœ¨ueé‡Œa2æ˜¯pow4 ï¼ˆroughnessï¼‰

```hlsl GGX
float D_GGX( float a2, float NoH )
{
	float d = ( NoH * a2 - NoH ) * NoH + 1;	// 2 mad
	return a2 / ( PI*d*d );					// 4 mul, 1 rcp
}
```

# Gé¡¹ï¼ˆå‡ ä½•å‡½æ•°ï¼‰

![Untitled](Untitled%205.png)

N dot Lå’ŒN dot Vè¦Max 0ï¼Œ
è¿™é‡Œçš„ k åŸºäºå‡ ä½•å‡½æ•°æ˜¯é’ˆå¯¹ç›´æ¥å…‰ç…§è¿˜æ˜¯é’ˆå¯¹IBLå…‰ç…§çš„é‡æ˜ å°„(Remapping)
åœ¨ueä¸­ç”¨çš„æ˜¯[Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
```hlsl G
float Vis_SmithJointApprox( float a2, float NoV, float NoL )
{
	float a = sqrt(a2);
	float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
	float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
	return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
}
```

![Untitled](Untitled%206.png)

# Fé¡¹ï¼ˆFresnelï¼‰
ä½¿ç”¨çš„æ˜¯Schlickè¿‘ä¼¼æ³•
![Untitled](Untitled%207.png)

è€Œueé‡‡ç”¨äº†
$$ F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0) ( 1 - (h \cdot v))^5 $$
```c++ F_Schlick
float3 F_Schlick( float3 SpecularColor, float VoH )
{
    float Fc = Pow5( 1 - VoH );                    // 1 sub, 3 mul
    return saturate( 50.0 * SpecularColor.g ) * Fc + (1 - Fc) * SpecularColor;
}


```
ä¸è¿‡ï¼ŒUEå¹¶æ²¡æœ‰å®Œå…¨ä½¿ç”¨ä»¥ä¸Šå…¬å¼ï¼Œè€Œæ˜¯ä¸ºäº†æ•ˆç‡é‡‡ç”¨çƒé¢é«˜æ–¯ï¼ˆSpherical Gaussianï¼‰è¿‘ä¼¼æ³•ä»£æ›¿äº†Powè¿ç®—ï¼š
$$ (ğ‘£,â„)=ğ¹0+(1âˆ’ğ¹0)2(âˆ’5.55473(ğ‘£â‹…â„)âˆ’6.98316)(ğ‘£â‹…â„) $$

```c++ F_Fresnel
float3 F_Fresnel( float3 SpecularColor, float VoH )
{
    float3 SpecularColorSqrt = sqrt( clamp( float3(0, 0, 0), float3(0.99, 0.99, 0.99), SpecularColor ) );
    float3 n = ( 1 + SpecularColorSqrt ) / ( 1 - SpecularColorSqrt );
    float3 g = sqrt( n*n + VoH*VoH - 1 );
    return 0.5 * Square( (g - VoH) / (g + VoH) ) * ( 1 + Square( ((g+VoH)*VoH - 1) / ((g-VoH)*VoH + 1) ) );
}

```

å„å‘å¼‚æ€§ Liå…‰å¼ºåº¦

Ksé«˜å…‰åå°„ç‡

h half vector ï¼šL add V

![Untitled](Untitled%2010.png)

# IBL

UEçš„IBLå°†å…‰ç…§ç§¯åˆ†ç”¨é»æ›¼å’Œæ–¹æ³•æ¥è¿‘ä¼¼æ¨¡æ‹Ÿï¼Œå…‰ç…§å‡½æ•°ç»“åˆäº†è’™ç‰¹å¡æ´›å’Œé‡è¦æ€§é‡‡æ ·ï¼Œå…¬å¼å¦‚ä¸‹ï¼š

$$ \int \limits_H L_i(l)f(l,v)\cos\theta_ldl \approx \frac{1}{N} \sum_{k=1}^N \cfrac{L_i(l_k)f(l_k,v)\cos\theta_{l_k}}{p(l_k,v)}$$

```c++ IBL
//é‡è¦æ€§é‡‡æ ·è’™å¾·å¡æ´›ç§¯åˆ†
float4 ImportanceSampleGGX( float2 E, float a2 )
{
    float Phi = 2 * PI * E.x;
    float CosTheta = sqrt( (1 - E.y) / ( 1 + (a2 - 1) * E.y ) );
    float SinTheta = sqrt( 1 - CosTheta * CosTheta );

    float3 H;
    H.x = SinTheta * cos( Phi );
    H.y = SinTheta * sin( Phi );
    H.z = CosTheta;
    
    float d = ( CosTheta * a2 - CosTheta ) * CosTheta + 1;
    float D = a2 / ( PI*d*d );
    float PDF = D * CosTheta;

    return float4( H, PDF );
}

float3 SpecularIBL( uint2 Random, float3 SpecularColor, float Roughness, float3 N, float3 V )
{
    float3 SpecularLighting = 0;

    const uint NumSamples = 32;
    for( uint i = 0; i < NumSamples; i++ )
    {
        float2 E = Hammersley( i, NumSamples, Random );
        float3 H = TangentToWorld( ImportanceSampleGGX( E, Pow4(Roughness) ).xyz, N );
        float3 L = 2 * dot( V, H ) * H - V;

        float NoV = saturate( dot( N, V ) );
        float NoL = saturate( dot( N, L ) );
        float NoH = saturate( dot( N, H ) );
        float VoH = saturate( dot( V, H ) );
        
        if( NoL > 0 )
        {
            float3 SampleColor = AmbientCubemap.SampleLevel( AmbientCubemapSampler, L, 0 ).rgb;

            float Vis = Vis_SmithJointApprox( Pow4(Roughness), NoV, NoL );
            float Fc = pow( 1 - VoH, 5 );
            float3 F = (1 - Fc) * SpecularColor + Fc;

            // Incident light = SampleColor * NoL
            // Microfacet specular = D*G*F / (4*NoL*NoV) = D*Vis*F
            // pdf = D * NoH / (4 * VoH)
            SpecularLighting += SampleColor * F * ( NoL * Vis * (4 * VoH / NoH) );
        }
    }

    return SpecularLighting / NumSamples;
}
```

å¯¹äºå…‰æºçš„è·ç¦»è¡°å‡å‡½æ•°ï¼ŒUEé‡‡ç”¨äº†å¦‚ä¸‹çš„ç‰©ç†è¿‘ä¼¼ï¼š

$$ \text{Falloff} = \cfrac{\text{saturate}(1-(\text{distance}/\text{lightRadius})^4)^2}{\text{distance}^2+1} $$

```c++ GetLocalLightAttenuation
// Engine\Shaders\Private\DeferredLightingCommon.ush

float GetLocalLightAttenuation(float3 WorldPosition, FDeferredLightData LightData, inout float3 ToLight, inout float3 L)
{
    ToLight = LightData.Position - WorldPosition;
        
    float DistanceSqr = dot( ToLight, ToLight );
    L = ToLight * rsqrt( DistanceSqr );

    float LightMask;
    if (LightData.bInverseSquared)
    {
        LightMask = Square( saturate( 1 - Square( DistanceSqr * Square(LightData.InvRadius) ) ) );
    }
    
    (......)

    return LightMask;
}

```