---
title: 图片压缩算法
date: 2022-04-07 12:00
tags: 图形学笔记
category: 笔记
---
# 图片压缩算法

# **DXTC**

DXTC（或BC）为微软为DX而推出的基于block的贴图压缩格式，其主要采用调色板的原理来进行压缩。

BC1:

基于4x4block来进行，不含有alpha通道，每个block内记录两个16bits的颜色做为基准颜色，然后解压时再使用两个基准色调制出另外两个颜色做为块内4个压缩颜色。其计算方式为：

basecolor2 = 2/3 *basecolor0 + 1/3 * basecolor1

basecolro3 = 1/3 *basecolor0 + 2/3 * basecolor1

对于每个块内的texel，存储2bits的索引，用来指向到4个基准颜色中的一个。所以对于BC1的压缩状态为64bits：

- 32bits：两个RGB565格式的基准颜色；
- 32bits：16个2bits的索引；

BC3：

在BC1的基础上支持alpha通道。首先，颜色的存储方式与BC1相同，需要64bits；对于alpha部分，使用与颜色部分相同的策略来处理。在block存储两个基准的alpha值，然后在其基础上插值得到其它6个共计8个alpha值，来做为alpha的调色板；然后对于每个texel存储一个3bits的索引，用来指向到这8个alpha中的一个。所以其对应的存储状态为：

- 32bits：两个RGB565格式的基准颜色；
- 32bits：16个2bits的颜色索引；
- 48bits：16个3bits的alpha索引；
- 16bits：2个8bits的基准alpha；

同时，两个alpha值中的不同的标记情况也对应着不同的插值操作：

若alpha0 > alpha1

alphai = (7 - i) / 7 *alpha0 + i/7 * alpha1；（2<=i<=7）；

若alpha0 < alpha1

alphai = (5 - i) / 5 *alpha0 + i/5 * alpha1；（2<=i<=5）;

alpha6 = 0；

alpha7=255；

# **ETC**

ETC压缩算法采用将图像中的chromatic和luminance分开存储的方式，而在解码时使用luminance对chromatic进行调制进而重现原始图像信息。

![Untitled](%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled.png)

ETC也主要有两种方法：ETC1和改进后的ETC2。

- ETC1:
    
    采用4x2的block进行分割（原始为4*2*24=192，压缩后为32，压缩率为6）：
    
    对于所有图片都使用一个全局的16个组table codeword，每组中有四个数值，且其中是有规律可循的，如下所示：
    
    ![Untitled](%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%201.png)
    
    - 12bits：RBG444的一个basecolor，其在使用是需要被扩展到8bits；每个block使用32bits进行编辑存储；比如对于RGB=(0,2,15) -> (0000 ,0010 , 1111)，扩展后为(000000,00100010 , 11111111)->(0 , 34 , 255)，扩展方法为直接将原始4位复制后拼接为8位即可；
    - 4bits：用来索引16个table codeword中的一组，比如｛-10 , -1 , 4 , 7｝；
    - 16bits：对于block中的每个pixel分配2bits，就有4个值，用来索引当前像素对应于table codeword中的每个modifier，该modifier需要组成三个通道的调整值，比如，对于某个pixel其对应的modifier索引值为2，也即对应上述table codeword中的4，如此一来该pixel的RGB = (0,34,255) + (4,4,4)=(4,38,259)，最后需要将其clamp至0,255，因而即为(4,38,255)。
    
    改进后采用4x4的block进行分割（原始为4*4*24= 384， 压缩后为64， 压缩率为6）：
    
    主要针对某两个4x2的block间的颜色差异相对较小，因而可以使用一个更多的bit来表示一个更高精度的basecolor，而另外一个basecolor则在其基础上通过一个bit较小的diff来进行动态计算得来。
    
    对于所有图片都使用一个全局的8个组table codeword，每组中有四个数值：
    
    ![Untitled](%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%202.png)
    
    - 1bit：用来记录两个字block是采用常规的4*2编码还是基于差值的编码；
    - 1bit：用来记录4x4的block内两个子block的朝向（可以两个4*2，也可以两个2*4）
    - 32bits：对于16个pixel，每个分配2bits的索引，指向到对应的modifier；
    - 6bits：对于每个子block，有一个3bits的索引，指向8个table codeword中的某一个（由原始的16组codeword缩减为8个）；
    - 24bits: 分别对应两个basecolor。对于常规编码时，则是两个RGB444，然后对每个扩展到RGB888；对于差值编码时，则是一个RGB555（精度较高）的basecolor和一个差值RGB333（较低精度），先计算出先求值，然后再扩展。
- ETC2
    
    根据ETC1的实现方式，如果其块内的颜色分布不均匀的话，则其存储的两个basecolor会较远的分布于插值趋线的较远的两侧，进行解压后会得到较低的压缩质量
    
    ![Untitled](%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%203.png)
    
    改进主要针对ETC1中的diff为1的情况下展开，即basecolor为RGB555和差值RGB333，此时另外一个颜色值= RGB555 + dRGB333，而其中的三个通道也是可以独立开来计算的，比如对于红色通道即为R = R5 + dR3，此时，若其中的R5为0且dR3为负值时得到的红色通道值就没有意义，此种情况下就可以对该block重新定义编码方式
    
    针对ETC1不支持透明通道的改进，用ETC2可以支持透明通道，不过要求OpenGL ES3.0及以上（Android4.3+），目前基本覆盖率在9成以上
    

# **PVRTC**

PVRTC的不是基于block的方式生成的，但是却也可以理解为以block方式组织的。其生成压缩后包含两张(w/4,h/4)大小的缩略图（w,h为原始图片的宽和高，可以理解为第4级的mipmap，但生成过程会比较mipmap的复杂），其中的每个pixel映射并对应到原始图像中的一个64x64的block上；然后使用1张与原始图像大小相同的modulate图，对应的每个pixel占2个bits，也即可对应四种调制方式，通过几种不同的调制方式还原出近似的原始像素值。

压缩后的一个4x4的block中的bits的组成内容为：

- 1bit：对应的融合方式，透明或不透明；
- 32bits：对应于16个pixel，每个pixel有2bits的调制因子；
- 31bits：对应两个缩略图中的该块映射到的两个像素上的颜色，若是透明模式，则两个颜色为RGBA44431，RGBA34431；若是不透明模式，则两个颜色为RGBA5551，RGBA4551;

![Untitled](%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%2037b07de836514407b210f68c9a91c0ec/Untitled%204.png)

通过调节上述两张缩略图的大小，可以相应的改变对应的压缩比，比如由（w/4，h/4）修改为（w/8，h/4），而其它的映射方式不变，即可将压缩比增大一倍。

# **ASTC**

ASTC中ARM研发的一种较新的贴图压缩格式，相对于上述几种方法具有较多的优势，其应该会慢慢成为之后移动设备上贴图压缩的主要标准和主流。其主要具有如下的特性：

1. 较高的灵活性；
2. 可变的压缩率；
3. 支持2d/3d贴图；
4. 适用于移动平台；
5. 支持LDR/HDR贴图内容；

ASTC同样是基于block的压缩方式，但块的大小却较支持多种尺寸，比如从基本的4x4到12x12，而且块的宽高也不限于pot，比如6x5；每个块内的内容用128bits来进行存储，因而不同的块就对应着不同的压缩率。

对于每个块，同样存储两个插值端点，称为endpoints，但是这里的endpoints不一定是基于颜色的（RGBA），也可以基于layer，比如对于R,G,B,A甚或其中的组合如RG等，这样的话就可以用来对normal map或alpha map进行更好的压缩；

对于块中的每个texel，存储其对应于endpoints的插件weight，但是存储的weight数量可以比texel少，特别是对于规格较大的块（比如12x12），这种情况下会首先对于每个texel通过线性插值得到其对就应的weight，然后再进行颜色的计算；

对于块内颜色分布较为复杂的情况，分析块内颜色的分布，然后做partition，对于每个partition进行分别的处理（与ETC2中将颜色分布对应到具体的预知分布模式中的处理方法不同），分别存储其对应的endpoints；这样一来对于块内的某个texel进行取值时就先定位其对应的partition，然后再计算在其在对应的小子块内的颜色。

块内信息的存储采用了BISE的方式来进行压缩，尽可能的节省对应的存储空间。比如对于一组5个表示范围已知的整型数值，采用BISE存储后可节省两个bits，这样就使用每个块内较大量的数据存储于128bits内成为可能；

对于单layer的一个block内的bits组织大概如下所示：

- 11bits: 存储weight, height, 以及特殊块的标识，比如void-extent等；
- 2bits: part数量；
- 4bits: 存储16种不同的endpoints的模式，比如是LDR或HDR，RGB或是RGBA；
- 111bit：其中存储endpoints，texel weight以及其它的配置信息，（注意，每种具体的存储大小是可变的，因其采用BISE进行压缩放置）；

更多的细节可以看这里

**4.1 Bounded Integer sequence encoding**

主要是针对范围限定的整数序列进行压缩存储进而节省空间。比如对于三个数4，78，55，其直接用binary的表示为0000100，1001110，0110111，直接存储二进制序列的话需要7bits * 3 = 21bits（在已知最大范围为78的情况下，不需要存储满8bits）。但是能不能在21bits的基础上再减少呢？BISE就是实现这样的目的的。

假设序列的范围为N，对应的bit位数为n：

- 若N<= 3*2^n-2，则其可用基于5的BISE压缩；
- 若N<=5*2^n-3，则其可用基于3的BISE压缩。

这里的背后其实是基于这样的一个事实，比如在基于3的压缩中，如果N<=3*2^n-2，那么在N的最高两位bit上，其并不会出现2^2种情况的所有组合（因其大小是受限的），到少11这样的组合就是没有的，否则其对应的值必定大于N。所以BISE压缩就是将受限的整数序列中的前两位数据中的无效bits进行合理使用。比如，在上述4，78，55的序列中，78 <= 5 * 2^4 = 80，所以可以使用基于5的BISE，将三个数的二进制序列构造为｛000 0100, 100 1100, 011 0111｝，高三位的组合为｛000，100，011｝，因这三个3位bits序列中的最大值是5，所以每三个bits最多有5种情况，那么这个高三位组合的序列共可能有5^3=125种组合情况，这样的话就可以使用7bits的空间来存储所有的这些组合，如此一来就可以将原来3*3=9bits的存储空间存储在7bits中，进而达到压缩的目的。